{"version":3,"file":"js/4185de081bbaf99a9dc6.js","mappings":"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","sources":["webpack:///../../node_modules/@pixi/text-bitmap/lib/text-bitmap.es.js"],"sourcesContent":["/*!\n * @pixi/text-bitmap - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/text-bitmap is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Rectangle, ObservablePoint, Point } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { MeshGeometry, MeshMaterial, Mesh } from '@pixi/mesh';\nimport { hex2rgb, string2hex, getResolutionOfUrl, deprecation, removeItems } from '@pixi/utils';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { TEXT_GRADIENT, TextStyle, TextMetrics } from '@pixi/text';\nimport { Container } from '@pixi/display';\nimport { LoaderResource } from '@pixi/loaders';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/* eslint-disable max-len */\n/**\n * Normalized parsed data from .fnt files.\n *\n * @class\n * @memberof PIXI\n */\nvar BitmapFontData = /** @class */ (function () {\n    function BitmapFontData() {\n        /**\n         * @member {PIXI.IBitmapFontDataInfo[]}\n         * @readOnly\n         */\n        this.info = [];\n        /**\n         * @member {PIXI.IBitmapFontDataCommon[]}\n         * @readOnly\n         */\n        this.common = [];\n        /**\n         * @member {PIXI.IBitmapFontDataPage[]}\n         * @readOnly\n         */\n        this.page = [];\n        /**\n         * @member {PIXI.IBitmapFontDataChar[]}\n         * @readOnly\n         */\n        this.char = [];\n        /**\n         * @member {PIXI.IBitmapFontDataKerning[]}\n         * @readOnly\n         */\n        this.kerning = [];\n    }\n    return BitmapFontData;\n}());\n/**\n * @memberof PIXI\n * @typedef {object} IBitmapFontDataInfo\n * @property {string} face\n * @property {number} size\n */\n/**\n * @memberof PIXI\n * @typedef {object} IBitmapFontDataCommon\n * @property {number} lineHeight\n */\n/**\n * @memberof PIXI\n * @typedef {object} IBitmapFontDataPage\n * @property {number} id\n * @property {string} file\n */\n/**\n * @memberof PIXI\n * @typedef {object} IBitmapFontDataChar\n * @property {string} id\n * @property {number} page\n * @property {number} x\n * @property {number} y\n * @property {number} width\n * @property {number} height\n * @property {number} xoffset\n * @property {number} yoffset\n * @property {number} xadvance\n */\n/**\n * @memberof PIXI\n * @typedef {object} IBitmapFontDataKerning\n * @property {number} first\n * @property {number} second\n * @property {number} amount\n */\n\n/**\n * BitmapFont format that's Text-based.\n *\n * @class\n * @private\n */\nvar TextFormat = /** @class */ (function () {\n    function TextFormat() {\n    }\n    /**\n     * Check if resource refers to txt font data.\n     *\n     * @static\n     * @private\n     * @param {any} data\n     * @return {boolean} True if resource could be treated as font data, false otherwise.\n     */\n    TextFormat.test = function (data) {\n        return typeof data === 'string' && data.indexOf('info face=') === 0;\n    };\n    /**\n     * Convert text font data to a javascript object.\n     *\n     * @static\n     * @private\n     * @param {string} txt - Raw string data to be converted\n     * @return {PIXI.BitmapFontData} Parsed font data\n     */\n    TextFormat.parse = function (txt) {\n        // Retrieve data item\n        var items = txt.match(/^[a-z]+\\s+.+$/gm);\n        var rawData = {\n            info: [],\n            common: [],\n            page: [],\n            char: [],\n            chars: [],\n            kerning: [],\n            kernings: [],\n        };\n        for (var i in items) {\n            // Extract item name\n            var name = items[i].match(/^[a-z]+/gm)[0];\n            // Extract item attribute list as string ex.: \"width=10\"\n            var attributeList = items[i].match(/[a-zA-Z]+=([^\\s\"']+|\"([^\"]*)\")/gm);\n            // Convert attribute list into an object\n            var itemData = {};\n            for (var i_1 in attributeList) {\n                // Split key-value pairs\n                var split = attributeList[i_1].split('=');\n                var key = split[0];\n                // Remove eventual quotes from value\n                var strValue = split[1].replace(/\"/gm, '');\n                // Try to convert value into float\n                var floatValue = parseFloat(strValue);\n                // Use string value case float value is NaN\n                var value = isNaN(floatValue) ? strValue : floatValue;\n                itemData[key] = value;\n            }\n            // Push current item to the resulting data\n            rawData[name].push(itemData);\n        }\n        var font = new BitmapFontData();\n        rawData.info.forEach(function (info) { return font.info.push({\n            face: info.face,\n            size: parseInt(info.size, 10),\n        }); });\n        rawData.common.forEach(function (common) { return font.common.push({\n            lineHeight: parseInt(common.lineHeight, 10),\n        }); });\n        rawData.page.forEach(function (page) { return font.page.push({\n            id: parseInt(page.id, 10),\n            file: page.file,\n        }); });\n        rawData.char.forEach(function (char) { return font.char.push({\n            id: parseInt(char.id, 10),\n            page: parseInt(char.page, 10),\n            x: parseInt(char.x, 10),\n            y: parseInt(char.y, 10),\n            width: parseInt(char.width, 10),\n            height: parseInt(char.height, 10),\n            xoffset: parseInt(char.xoffset, 10),\n            yoffset: parseInt(char.yoffset, 10),\n            xadvance: parseInt(char.xadvance, 10),\n        }); });\n        rawData.kerning.forEach(function (kerning) { return font.kerning.push({\n            first: parseInt(kerning.first, 10),\n            second: parseInt(kerning.second, 10),\n            amount: parseInt(kerning.amount, 10),\n        }); });\n        return font;\n    };\n    return TextFormat;\n}());\n\n/**\n * BitmapFont format that's XML-based.\n *\n * @class\n * @private\n */\nvar XMLFormat = /** @class */ (function () {\n    function XMLFormat() {\n    }\n    /**\n     * Check if resource refers to xml font data.\n     *\n     * @static\n     * @private\n     * @param {any} data\n     * @return {boolean} True if resource could be treated as font data, false otherwise.\n     */\n    XMLFormat.test = function (data) {\n        return data instanceof XMLDocument\n            && data.getElementsByTagName('page').length\n            && data.getElementsByTagName('info')[0].getAttribute('face') !== null;\n    };\n    /**\n     * Convert the XML into BitmapFontData that we can use.\n     *\n     * @static\n     * @private\n     * @param {XMLDocument} xml\n     * @return {BitmapFontData} Data to use for BitmapFont\n     */\n    XMLFormat.parse = function (xml) {\n        var data = new BitmapFontData();\n        var info = xml.getElementsByTagName('info');\n        var common = xml.getElementsByTagName('common');\n        var page = xml.getElementsByTagName('page');\n        var char = xml.getElementsByTagName('char');\n        var kerning = xml.getElementsByTagName('kerning');\n        for (var i = 0; i < info.length; i++) {\n            data.info.push({\n                face: info[i].getAttribute('face'),\n                size: parseInt(info[i].getAttribute('size'), 10),\n            });\n        }\n        for (var i = 0; i < common.length; i++) {\n            data.common.push({\n                lineHeight: parseInt(common[i].getAttribute('lineHeight'), 10),\n            });\n        }\n        for (var i = 0; i < page.length; i++) {\n            data.page.push({\n                id: parseInt(page[i].getAttribute('id'), 10) || 0,\n                file: page[i].getAttribute('file'),\n            });\n        }\n        for (var i = 0; i < char.length; i++) {\n            var letter = char[i];\n            data.char.push({\n                id: parseInt(letter.getAttribute('id'), 10),\n                page: parseInt(letter.getAttribute('page'), 10) || 0,\n                x: parseInt(letter.getAttribute('x'), 10),\n                y: parseInt(letter.getAttribute('y'), 10),\n                width: parseInt(letter.getAttribute('width'), 10),\n                height: parseInt(letter.getAttribute('height'), 10),\n                xoffset: parseInt(letter.getAttribute('xoffset'), 10),\n                yoffset: parseInt(letter.getAttribute('yoffset'), 10),\n                xadvance: parseInt(letter.getAttribute('xadvance'), 10),\n            });\n        }\n        for (var i = 0; i < kerning.length; i++) {\n            data.kerning.push({\n                first: parseInt(kerning[i].getAttribute('first'), 10),\n                second: parseInt(kerning[i].getAttribute('second'), 10),\n                amount: parseInt(kerning[i].getAttribute('amount'), 10),\n            });\n        }\n        return data;\n    };\n    return XMLFormat;\n}());\n\n/**\n * BitmapFont format that's XML-based.\n *\n * @class\n * @private\n */\nvar XMLStringFormat = /** @class */ (function () {\n    function XMLStringFormat() {\n    }\n    /**\n     * Check if resource refers to text xml font data.\n     *\n     * @static\n     * @private\n     * @param {any} data\n     * @return {boolean} True if resource could be treated as font data, false otherwise.\n     */\n    XMLStringFormat.test = function (data) {\n        if (typeof data === 'string' && data.indexOf('<font>') > -1) {\n            var xml = new self.DOMParser().parseFromString(data, 'text/xml');\n            return XMLFormat.test(xml);\n        }\n        return false;\n    };\n    /**\n     * Convert the text XML into BitmapFontData that we can use.\n     *\n     * @static\n     * @private\n     * @param {string} xmlTxt\n     * @return {BitmapFontData} Data to use for BitmapFont\n     */\n    XMLStringFormat.parse = function (xmlTxt) {\n        var xml = new window.DOMParser().parseFromString(xmlTxt, 'text/xml');\n        return XMLFormat.parse(xml);\n    };\n    return XMLStringFormat;\n}());\n\n// Registered formats, maybe make this extensible in the future?\nvar formats = [\n    TextFormat,\n    XMLFormat,\n    XMLStringFormat ];\n/**\n * Auto-detect BitmapFont parsing format based on data.\n * @private\n * @param {any} data - Data to detect format\n * @return {any} Format or null\n */\nfunction autoDetectFormat(data) {\n    for (var i = 0; i < formats.length; i++) {\n        if (formats[i].test(data)) {\n            return formats[i];\n        }\n    }\n    return null;\n}\n\n// TODO: Prevent code duplication b/w generateFillStyle & Text#generateFillStyle\n/**\n * Generates the fill style. Can automatically generate a gradient based on the fill style being an array\n *\n * @private\n * @param {object} style - The style.\n * @param {string[]} lines - The lines of text.\n * @return {string|number|CanvasGradient} The fill style\n */\nfunction generateFillStyle(canvas, context, style, resolution, lines, metrics) {\n    // TODO: Can't have different types for getter and setter. The getter shouldn't have the number type as\n    //       the setter converts to string. See this thread for more details:\n    //       https://github.com/microsoft/TypeScript/issues/2521\n    var fillStyle = style.fill;\n    if (!Array.isArray(fillStyle)) {\n        return fillStyle;\n    }\n    else if (fillStyle.length === 1) {\n        return fillStyle[0];\n    }\n    // the gradient will be evenly spaced out according to how large the array is.\n    // ['#FF0000', '#00FF00', '#0000FF'] would created stops at 0.25, 0.5 and 0.75\n    var gradient;\n    // a dropshadow will enlarge the canvas and result in the gradient being\n    // generated with the incorrect dimensions\n    var dropShadowCorrection = (style.dropShadow) ? style.dropShadowDistance : 0;\n    // should also take padding into account, padding can offset the gradient\n    var padding = style.padding || 0;\n    var width = Math.ceil(canvas.width / resolution) - dropShadowCorrection - (padding * 2);\n    var height = Math.ceil(canvas.height / resolution) - dropShadowCorrection - (padding * 2);\n    // make a copy of the style settings, so we can manipulate them later\n    var fill = fillStyle.slice();\n    var fillGradientStops = style.fillGradientStops.slice();\n    // wanting to evenly distribute the fills. So an array of 4 colours should give fills of 0.25, 0.5 and 0.75\n    if (!fillGradientStops.length) {\n        var lengthPlus1 = fill.length + 1;\n        for (var i = 1; i < lengthPlus1; ++i) {\n            fillGradientStops.push(i / lengthPlus1);\n        }\n    }\n    // stop the bleeding of the last gradient on the line above to the top gradient of the this line\n    // by hard defining the first gradient colour at point 0, and last gradient colour at point 1\n    fill.unshift(fillStyle[0]);\n    fillGradientStops.unshift(0);\n    fill.push(fillStyle[fillStyle.length - 1]);\n    fillGradientStops.push(1);\n    if (style.fillGradientType === TEXT_GRADIENT.LINEAR_VERTICAL) {\n        // start the gradient at the top center of the canvas, and end at the bottom middle of the canvas\n        gradient = context.createLinearGradient(width / 2, padding, width / 2, height + padding);\n        // we need to repeat the gradient so that each individual line of text has the same vertical gradient effect\n        // ['#FF0000', '#00FF00', '#0000FF'] over 2 lines would create stops at 0.125, 0.25, 0.375, 0.625, 0.75, 0.875\n        // There's potential for floating point precision issues at the seams between gradient repeats.\n        // The loop below generates the stops in order, so track the last generated one to prevent\n        // floating point precision from making us go the teeniest bit backwards, resulting in\n        // the first and last colors getting swapped.\n        var lastIterationStop = 0;\n        // Actual height of the text itself, not counting spacing for lineHeight/leading/dropShadow etc\n        var textHeight = metrics.fontProperties.fontSize + style.strokeThickness;\n        // textHeight, but as a 0-1 size in global gradient stop space\n        var gradStopLineHeight = textHeight / height;\n        for (var i = 0; i < lines.length; i++) {\n            var thisLineTop = metrics.lineHeight * i;\n            for (var j = 0; j < fill.length; j++) {\n                // 0-1 stop point for the current line, multiplied to global space afterwards\n                var lineStop = 0;\n                if (typeof fillGradientStops[j] === 'number') {\n                    lineStop = fillGradientStops[j];\n                }\n                else {\n                    lineStop = j / fill.length;\n                }\n                var globalStop = (thisLineTop / height) + (lineStop * gradStopLineHeight);\n                // Prevent color stop generation going backwards from floating point imprecision\n                var clampedStop = Math.max(lastIterationStop, globalStop);\n                clampedStop = Math.min(clampedStop, 1); // Cap at 1 as well for safety's sake to avoid a possible throw.\n                gradient.addColorStop(clampedStop, fill[j]);\n                lastIterationStop = clampedStop;\n            }\n        }\n    }\n    else {\n        // start the gradient at the center left of the canvas, and end at the center right of the canvas\n        gradient = context.createLinearGradient(padding, height / 2, width + padding, height / 2);\n        // can just evenly space out the gradients in this case, as multiple lines makes no difference\n        // to an even left to right gradient\n        var totalIterations = fill.length + 1;\n        var currentIteration = 1;\n        for (var i = 0; i < fill.length; i++) {\n            var stop = void 0;\n            if (typeof fillGradientStops[i] === 'number') {\n                stop = fillGradientStops[i];\n            }\n            else {\n                stop = currentIteration / totalIterations;\n            }\n            gradient.addColorStop(stop, fill[i]);\n            currentIteration++;\n        }\n    }\n    return gradient;\n}\n\n// TODO: Prevent code duplication b/w drawGlyph & Text#updateText\n/**\n * Draws the glyph `metrics.text` on the given canvas.\n *\n * Ignored because not directly exposed.\n *\n * @ignore\n * @param {HTMLCanvasElement} canvas\n * @param {CanvasRenderingContext2D} context\n * @param {TextMetrics} metrics\n * @param {number} x\n * @param {number} y\n * @param {number} resolution\n * @param {TextStyle} style\n */\nfunction drawGlyph(canvas, context, metrics, x, y, resolution, style) {\n    var char = metrics.text;\n    var fontProperties = metrics.fontProperties;\n    context.translate(x, y);\n    context.scale(resolution, resolution);\n    var tx = style.strokeThickness / 2;\n    var ty = -(style.strokeThickness / 2);\n    context.font = style.toFontString();\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    // set canvas text styles\n    context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n    context.strokeStyle = style.stroke;\n    context.font = style.toFontString();\n    context.lineWidth = style.strokeThickness;\n    context.textBaseline = style.textBaseline;\n    context.lineJoin = style.lineJoin;\n    context.miterLimit = style.miterLimit;\n    // set canvas text styles\n    context.fillStyle = generateFillStyle(canvas, context, style, resolution, [char], metrics);\n    context.strokeStyle = style.stroke;\n    var dropShadowColor = style.dropShadowColor;\n    var rgb = hex2rgb(typeof dropShadowColor === 'number' ? dropShadowColor : string2hex(dropShadowColor));\n    if (style.dropShadow) {\n        context.shadowColor = \"rgba(\" + rgb[0] * 255 + \",\" + rgb[1] * 255 + \",\" + rgb[2] * 255 + \",\" + style.dropShadowAlpha + \")\";\n        context.shadowBlur = style.dropShadowBlur;\n        context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n        context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n    }\n    else {\n        context.shadowColor = 'black';\n        context.shadowBlur = 0;\n        context.shadowOffsetX = 0;\n        context.shadowOffsetY = 0;\n    }\n    if (style.stroke && style.strokeThickness) {\n        context.strokeText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n    if (style.fill) {\n        context.fillText(char, tx, ty + metrics.lineHeight - fontProperties.descent);\n    }\n    context.setTransform(1, 0, 0, 1, 0, 0); // defaults needed for older browsers (e.g. Opera 29)\n    context.fillStyle = 'rgba(0, 0, 0, 0)';\n}\n\n/**\n * Processes the passed character set data and returns a flattened array of all the characters.\n *\n * Ignored because not directly exposed.\n *\n * @ignore\n * @param {string | string[] | string[][] } chars\n * @returns {string[]}\n */\nfunction resolveCharacters(chars) {\n    // Split the chars string into individual characters\n    if (typeof chars === 'string') {\n        chars = [chars];\n    }\n    // Handle an array of characters+ranges\n    var result = [];\n    for (var i = 0, j = chars.length; i < j; i++) {\n        var item = chars[i];\n        // Handle range delimited by start/end chars\n        if (Array.isArray(item)) {\n            if (item.length !== 2) {\n                throw new Error(\"[BitmapFont]: Invalid character range length, expecting 2 got \" + item.length + \".\");\n            }\n            var startCode = item[0].charCodeAt(0);\n            var endCode = item[1].charCodeAt(0);\n            if (endCode < startCode) {\n                throw new Error('[BitmapFont]: Invalid character range.');\n            }\n            for (var i_1 = startCode, j_1 = endCode; i_1 <= j_1; i_1++) {\n                result.push(String.fromCharCode(i_1));\n            }\n        }\n        // Handle a character set string\n        else {\n            result.push.apply(result, item.split(''));\n        }\n    }\n    if (result.length === 0) {\n        throw new Error('[BitmapFont]: Empty set when resolving characters.');\n    }\n    return result;\n}\n\n/**\n * BitmapFont represents a typeface available for use with the BitmapText class. Use the `install`\n * method for adding a font to be used.\n *\n * @class\n * @memberof PIXI\n */\nvar BitmapFont = /** @class */ (function () {\n    /**\n     * @param {PIXI.BitmapFontData} data\n     * @param {PIXI.Texture[]|Object.<string, PIXI.Texture>} textures\n     * @param {boolean} [ownsTextures] - Setting to `true` will destroy page textures\n     *        when the font is uninstalled.\n     */\n    function BitmapFont(data, textures, ownsTextures) {\n        var info = data.info[0];\n        var common = data.common[0];\n        var page = data.page[0];\n        var res = getResolutionOfUrl(page.file);\n        var pageTextures = {};\n        this._ownsTextures = ownsTextures;\n        /**\n         * The name of the font face.\n         *\n         * @member {string}\n         * @readonly\n         */\n        this.font = info.face;\n        /**\n         * The size of the font face in pixels.\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.size = info.size;\n        /**\n         * The line-height of the font face in pixels.\n         *\n         * @member {number}\n         * @readonly\n         */\n        this.lineHeight = common.lineHeight / res;\n        /**\n         * The map of characters by character code.\n         *\n         * @member {object}\n         * @readonly\n         */\n        this.chars = {};\n        /**\n         * The map of base page textures (i.e., sheets of glyphs).\n         *\n         * @member {object}\n         * @readonly\n         * @private\n         */\n        this.pageTextures = pageTextures;\n        // Convert the input Texture, Textures or object\n        // into a page Texture lookup by \"id\"\n        for (var i = 0; i < data.page.length; i++) {\n            var _a = data.page[i], id = _a.id, file = _a.file;\n            pageTextures[id] = textures instanceof Array\n                ? textures[i] : textures[file];\n        }\n        // parse letters\n        for (var i = 0; i < data.char.length; i++) {\n            var _b = data.char[i], id = _b.id, page_1 = _b.page;\n            var _c = data.char[i], x = _c.x, y = _c.y, width = _c.width, height = _c.height, xoffset = _c.xoffset, yoffset = _c.yoffset, xadvance = _c.xadvance;\n            x /= res;\n            y /= res;\n            width /= res;\n            height /= res;\n            xoffset /= res;\n            yoffset /= res;\n            xadvance /= res;\n            var rect = new Rectangle(x + (pageTextures[page_1].frame.x / res), y + (pageTextures[page_1].frame.y / res), width, height);\n            this.chars[id] = {\n                xOffset: xoffset,\n                yOffset: yoffset,\n                xAdvance: xadvance,\n                kerning: {},\n                texture: new Texture(pageTextures[page_1].baseTexture, rect),\n                page: page_1,\n            };\n        }\n        // parse kernings\n        for (var i = 0; i < data.kerning.length; i++) {\n            var _d = data.kerning[i], first = _d.first, second = _d.second, amount = _d.amount;\n            first /= res;\n            second /= res;\n            amount /= res;\n            if (this.chars[second]) {\n                this.chars[second].kerning[first] = amount;\n            }\n        }\n    }\n    /**\n     * Remove references to created glyph textures.\n     */\n    BitmapFont.prototype.destroy = function () {\n        for (var id in this.chars) {\n            this.chars[id].texture.destroy();\n            this.chars[id].texture = null;\n        }\n        for (var id in this.pageTextures) {\n            if (this._ownsTextures) {\n                this.pageTextures[id].destroy(true);\n            }\n            this.pageTextures[id] = null;\n        }\n        // Set readonly null.\n        this.chars = null;\n        this.pageTextures = null;\n    };\n    /**\n     * Register a new bitmap font.\n     *\n     * @static\n     * @param {XMLDocument|string|PIXI.BitmapFontData} data - The\n     *        characters map that could be provided as xml or raw string.\n     * @param {Object.<string, PIXI.Texture>|PIXI.Texture|PIXI.Texture[]}\n     *        textures - List of textures for each page.\n     * @param {boolean} managedTexture - Set to `true` to destroy page textures\n     *        when the font is uninstalled. By default fonts created with\n     *        `BitmapFont.from` or from the `BitmapFontLoader` are `true`.\n     * @return {PIXI.BitmapFont} Result font object with font, size, lineHeight\n     *         and char fields.\n     */\n    BitmapFont.install = function (data, textures, ownsTextures) {\n        var fontData;\n        if (data instanceof BitmapFontData) {\n            fontData = data;\n        }\n        else {\n            var format = autoDetectFormat(data);\n            if (!format) {\n                throw new Error('Unrecognized data format for font.');\n            }\n            fontData = format.parse(data);\n        }\n        // Single texture, convert to list\n        if (textures instanceof Texture) {\n            textures = [textures];\n        }\n        var font = new BitmapFont(fontData, textures, ownsTextures);\n        BitmapFont.available[font.font] = font;\n        return font;\n    };\n    /**\n     * Remove bitmap font by name.\n     *\n     * @static\n     * @param {string} name - Name of the font to uninstall.\n     */\n    BitmapFont.uninstall = function (name) {\n        var font = BitmapFont.available[name];\n        if (!font) {\n            throw new Error(\"No font found named '\" + name + \"'\");\n        }\n        font.destroy();\n        delete BitmapFont.available[name];\n    };\n    /**\n     * Generates a bitmap-font for the given style and character set. This does not support\n     * kernings yet. With `style` properties, only the following non-layout properties are used:\n     *\n     * - {@link PIXI.TextStyle#dropShadow|dropShadow}\n     * - {@link PIXI.TextStyle#dropShadowDistance|dropShadowDistance}\n     * - {@link PIXI.TextStyle#dropShadowColor|dropShadowColor}\n     * - {@link PIXI.TextStyle#dropShadowBlur|dropShadowBlur}\n     * - {@link PIXI.TextStyle#dropShadowAngle|dropShadowAngle}\n     * - {@link PIXI.TextStyle#fill|fill}\n     * - {@link PIXI.TextStyle#fillGradientStops|fillGradientStops}\n     * - {@link PIXI.TextStyle#fillGradientType|fillGradientType}\n     * - {@link PIXI.TextStyle#fontFamily|fontFamily}\n     * - {@link PIXI.TextStyle#fontSize|fontSize}\n     * - {@link PIXI.TextStyle#fontVariant|fontVariant}\n     * - {@link PIXI.TextStyle#fontWeight|fontWeight}\n     * - {@link PIXI.TextStyle#lineJoin|lineJoin}\n     * - {@link PIXI.TextStyle#miterLimit|miterLimit}\n     * - {@link PIXI.TextStyle#stroke|stroke}\n     * - {@link PIXI.TextStyle#strokeThickness|strokeThickness}\n     * - {@link PIXI.TextStyle#textBaseline|textBaseline}\n     *\n     * @param {string} name - The name of the custom font to use with BitmapText.\n     * @param {object|PIXI.TextStyle} [style] - Style options to render with BitmapFont.\n     * @param {PIXI.IBitmapFontOptions} [options] - Setup options for font or name of the font.\n     * @param {string|string[]|string[][]} [options.chars=PIXI.BitmapFont.ALPHANUMERIC] - characters included\n     *      in the font set. You can also use ranges. For example, `[['a', 'z'], ['A', 'Z'], \"!@#$%^&*()~{}[] \"]`.\n     *      Don't forget to include spaces ' ' in your character set!\n     * @param {number} [options.resolution=1] - Render resolution for glyphs.\n     * @param {number} [options.textureWidth=512] - Optional width of atlas, smaller values to reduce memory.\n     * @param {number} [options.textureHeight=512] - Optional height of atlas, smaller values to reduce memory.\n     * @param {number} [options.padding=4] - Padding between glyphs on texture atlas.\n     * @return {PIXI.BitmapFont} Font generated by style options.\n     * @static\n     * @example\n     * PIXI.BitmapFont.from(\"TitleFont\", {\n     *     fontFamily: \"Arial\",\n     *     fontSize: 12,\n     *     strokeThickness: 2,\n     *     fill: \"purple\"\n     * });\n     *\n     * const title = new PIXI.BitmapText(\"This is the title\", { fontName: \"TitleFont\" });\n     */\n    BitmapFont.from = function (name, textStyle, options) {\n        if (!name) {\n            throw new Error('[BitmapFont] Property `name` is required.');\n        }\n        var _a = Object.assign({}, BitmapFont.defaultOptions, options), chars = _a.chars, padding = _a.padding, resolution = _a.resolution, textureWidth = _a.textureWidth, textureHeight = _a.textureHeight;\n        var charsList = resolveCharacters(chars);\n        var style = textStyle instanceof TextStyle ? textStyle : new TextStyle(textStyle);\n        var lineWidth = textureWidth;\n        var fontData = new BitmapFontData();\n        fontData.info[0] = {\n            face: style.fontFamily,\n            size: style.fontSize,\n        };\n        fontData.common[0] = {\n            lineHeight: style.fontSize,\n        };\n        var positionX = 0;\n        var positionY = 0;\n        var canvas;\n        var context;\n        var baseTexture;\n        var maxCharHeight = 0;\n        var textures = [];\n        for (var i = 0; i < charsList.length; i++) {\n            if (!canvas) {\n                canvas = document.createElement('canvas');\n                canvas.width = textureWidth;\n                canvas.height = textureHeight;\n                context = canvas.getContext('2d');\n                baseTexture = new BaseTexture(canvas, { resolution: resolution });\n                textures.push(new Texture(baseTexture));\n                fontData.page.push({\n                    id: textures.length - 1,\n                    file: '',\n                });\n            }\n            // Measure glyph dimensions\n            var metrics = TextMetrics.measureText(charsList[i], style, false, canvas);\n            var width = metrics.width;\n            var height = Math.ceil(metrics.height);\n            // This is ugly - but italics are given more space so they don't overlap\n            var textureGlyphWidth = Math.ceil((style.fontStyle === 'italic' ? 2 : 1) * width);\n            // Can't fit char anymore: next canvas please!\n            if (positionY >= textureHeight - (height * resolution)) {\n                if (positionY === 0) {\n                    // We don't want user debugging an infinite loop (or do we? :)\n                    throw new Error(\"[BitmapFont] textureHeight \" + textureHeight + \"px is \"\n                        + (\"too small for \" + style.fontSize + \"px fonts\"));\n                }\n                --i;\n                // Create new atlas once current has filled up\n                canvas = null;\n                context = null;\n                baseTexture = null;\n                positionY = 0;\n                positionX = 0;\n                maxCharHeight = 0;\n                continue;\n            }\n            maxCharHeight = Math.max(height + metrics.fontProperties.descent, maxCharHeight);\n            // Wrap line once full row has been rendered\n            if ((textureGlyphWidth * resolution) + positionX >= lineWidth) {\n                --i;\n                positionY += maxCharHeight * resolution;\n                positionY = Math.ceil(positionY);\n                positionX = 0;\n                maxCharHeight = 0;\n                continue;\n            }\n            drawGlyph(canvas, context, metrics, positionX, positionY, resolution, style);\n            // Unique (numeric) ID mapping to this glyph\n            var id = metrics.text.charCodeAt(0);\n            // Create a texture holding just the glyph\n            fontData.char.push({\n                id: id,\n                page: textures.length - 1,\n                x: positionX / resolution,\n                y: positionY / resolution,\n                width: textureGlyphWidth,\n                height: height,\n                xoffset: 0,\n                yoffset: 0,\n                xadvance: Math.ceil(width\n                    - (style.dropShadow ? style.dropShadowDistance : 0)\n                    - (style.stroke ? style.strokeThickness : 0)),\n            });\n            positionX += (textureGlyphWidth + (2 * padding)) * resolution;\n            positionX = Math.ceil(positionX);\n        }\n        var font = new BitmapFont(fontData, textures, true);\n        // Make it easier to replace a font\n        if (BitmapFont.available[name] !== undefined) {\n            BitmapFont.uninstall(name);\n        }\n        BitmapFont.available[name] = font;\n        return font;\n    };\n    /**\n     * This character set includes all the letters in the alphabet (both lower- and upper- case).\n     * @readonly\n     * @static\n     * @member {string[][]}\n     * @example\n     * BitmapFont.from(\"ExampleFont\", style, { chars: BitmapFont.ALPHA })\n     */\n    BitmapFont.ALPHA = [['a', 'z'], ['A', 'Z'], ' '];\n    /**\n     * This character set includes all decimal digits (from 0 to 9).\n     * @readonly\n     * @static\n     * @member {string[][]}\n     * @example\n     * BitmapFont.from(\"ExampleFont\", style, { chars: BitmapFont.NUMERIC })\n     */\n    BitmapFont.NUMERIC = [['0', '9']];\n    /**\n     * This character set is the union of `BitmapFont.ALPHA` and `BitmapFont.NUMERIC`.\n     * @readonly\n     * @static\n     * @member {string[][]}\n     */\n    BitmapFont.ALPHANUMERIC = [['a', 'z'], ['A', 'Z'], ['0', '9'], ' '];\n    /**\n     * This character set consists of all the ASCII table.\n     * @readonly\n     * @static\n     * @member {string[][]}\n     * @see http://www.asciitable.com/\n     */\n    BitmapFont.ASCII = [[' ', '~']];\n    /**\n     * Collection of default options when using `BitmapFont.from`.\n     *\n     * @readonly\n     * @static\n     * @member {PIXI.IBitmapFontOptions}\n     * @property {number} resolution=1\n     * @property {number} textureWidth=512\n     * @property {number} textureHeight=512\n     * @property {number} padding=4\n     * @property {string|string[]|string[][]} chars=PIXI.BitmapFont.ALPHANUMERIC\n     */\n    BitmapFont.defaultOptions = {\n        resolution: 1,\n        textureWidth: 512,\n        textureHeight: 512,\n        padding: 4,\n        chars: BitmapFont.ALPHANUMERIC,\n    };\n    /**\n     * Collection of available/installed fonts.\n     *\n     * @readonly\n     * @static\n     * @member {Object.<string, PIXI.BitmapFont>}\n     */\n    BitmapFont.available = {};\n    return BitmapFont;\n}());\n/**\n * @memberof PIXI\n * @interface IBitmapFontOptions\n * @property {string | string[] | string[][]} [chars=PIXI.BitmapFont.ALPHANUMERIC] - the character set to generate\n * @property {number} [resolution=1] - the resolution for rendering\n * @property {number} [padding=4] - the padding between glyphs in the atlas\n * @property {number} [textureWidth=512] - the width of the texture atlas\n * @property {number} [textureHeight=512] - the height of the texture atlas\n */\n\nvar pageMeshDataPool = [];\nvar charRenderDataPool = [];\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font.\n *\n * The primary advantage of this class over Text is that all of your textures are pre-generated and loading,\n * meaning that rendering is fast, and changing text has no performance implications.\n *\n * Supporting character sets other than latin, such as CJK languages, may be impractical due to the number of characters.\n *\n * To split a line you can use '\\n', '\\r' or '\\r\\n' in your string.\n *\n * PixiJS can auto-generate fonts on-the-fly using BitmapFont or use fnt files provided by:\n * http://www.angelcode.com/products/bmfont/ for Windows or\n * http://www.bmglyph.com/ for Mac.\n *\n * A BitmapText can only be created when the font is loaded.\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * let bitmapText = new PIXI.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nvar BitmapText = /** @class */ (function (_super) {\n    __extends(BitmapText, _super);\n    /**\n     * @param {string} text - A string that you would like the text to display.\n     * @param {object} style - The style parameters.\n     * @param {string} style.fontName - The installed BitmapFont name.\n     * @param {number} [style.fontSize] - The size of the font in pixels, e.g. 24. If undefined,\n     *.     this will default to the BitmapFont size.\n     * @param {string} [style.align='left'] - Alignment for multiline text ('left', 'center' or 'right'),\n     *      does not affect single line text.\n     * @param {number} [style.tint=0xFFFFFF] - The tint color.\n     * @param {number} [style.letterSpacing=0] - The amount of spacing between letters.\n     * @param {number} [style.maxWidth=0] - The max width of the text before line wrapping.\n     */\n    function BitmapText(text, style) {\n        if (style === void 0) { style = {}; }\n        var _this = _super.call(this) || this;\n        _this._tint = 0xFFFFFF;\n        if (style.font) {\n            deprecation('5.3.0', 'PIXI.BitmapText constructor style.font property is deprecated.');\n            _this._upgradeStyle(style);\n        }\n        // Apply the defaults\n        var _a = Object.assign({}, BitmapText.styleDefaults, style), align = _a.align, tint = _a.tint, maxWidth = _a.maxWidth, letterSpacing = _a.letterSpacing, fontName = _a.fontName, fontSize = _a.fontSize;\n        if (!BitmapFont.available[fontName]) {\n            throw new Error(\"Missing BitmapFont \\\"\" + fontName + \"\\\"\");\n        }\n        /**\n         * Collection of page mesh data.\n         *\n         * @member {object}\n         * @private\n         */\n        _this._activePagesMeshData = [];\n        /**\n         * Private tracker for the width of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        _this._textWidth = 0;\n        /**\n         * Private tracker for the height of the overall text\n         *\n         * @member {number}\n         * @private\n         */\n        _this._textHeight = 0;\n        /**\n         * Private tracker for the current text align.\n         *\n         * @member {string}\n         * @private\n         */\n        _this._align = align;\n        /**\n         * Private tracker for the current tint.\n         *\n         * @member {number}\n         * @private\n         */\n        _this._tint = tint;\n        /**\n         * Private tracker for the current font name.\n         *\n         * @member {string}\n         * @private\n         */\n        _this._fontName = fontName;\n        /**\n         * Private tracker for the current font size.\n         *\n         * @member {number}\n         * @private\n         */\n        _this._fontSize = fontSize || BitmapFont.available[fontName].size;\n        /**\n         * Private tracker for the current text.\n         *\n         * @member {string}\n         * @private\n         */\n        _this._text = text;\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting value to 0\n         *\n         * @member {number}\n         * @private\n         */\n        _this._maxWidth = maxWidth;\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * ie: when trying to vertically align. (Internally used)\n         *\n         * @member {number}\n         * @private\n         */\n        _this._maxLineHeight = 0;\n        /**\n         * Letter spacing. This is useful for setting the space between characters.\n         * @member {number}\n         * @private\n         */\n        _this._letterSpacing = letterSpacing;\n        /**\n         * Text anchor. read-only\n         *\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        _this._anchor = new ObservablePoint(function () { _this.dirty = true; }, _this, 0, 0);\n        /**\n         * If true PixiJS will Math.floor() x/y values when rendering\n         *\n         * @member {boolean}\n         * @default PIXI.settings.ROUND_PIXELS\n         */\n        _this._roundPixels = settings.ROUND_PIXELS;\n        /**\n         * Set to `true` if the BitmapText needs to be redrawn.\n         *\n         * @member {boolean}\n         */\n        _this.dirty = true;\n        /**\n         * Cached char texture is destroyed when BitmapText is destroyed\n         * @member {Record<number, Texture>}\n         * @private\n         */\n        _this._textureCache = {};\n        return _this;\n    }\n    /**\n     * Renders text and updates it when needed. This should only be called\n     * if the BitmapFont is regenerated.\n     */\n    BitmapText.prototype.updateText = function () {\n        var _a;\n        var data = BitmapFont.available[this._fontName];\n        var scale = this._fontSize / data.size;\n        var pos = new Point();\n        var chars = [];\n        var lineWidths = [];\n        var text = this._text.replace(/(?:\\r\\n|\\r)/g, '\\n') || ' ';\n        var textLength = text.length;\n        var maxWidth = this._maxWidth * data.size / this._fontSize;\n        var prevCharCode = null;\n        var lastLineWidth = 0;\n        var maxLineWidth = 0;\n        var line = 0;\n        var lastBreakPos = -1;\n        var lastBreakWidth = 0;\n        var spacesRemoved = 0;\n        var maxLineHeight = 0;\n        for (var i = 0; i < textLength; i++) {\n            var charCode = text.charCodeAt(i);\n            var char = text.charAt(i);\n            if ((/(?:\\s)/).test(char)) {\n                lastBreakPos = i;\n                lastBreakWidth = lastLineWidth;\n            }\n            if (char === '\\r' || char === '\\n') {\n                lineWidths.push(lastLineWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n                ++line;\n                ++spacesRemoved;\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n                continue;\n            }\n            var charData = data.chars[charCode];\n            if (!charData) {\n                continue;\n            }\n            if (prevCharCode && charData.kerning[prevCharCode]) {\n                pos.x += charData.kerning[prevCharCode];\n            }\n            var charRenderData = charRenderDataPool.pop() || {\n                texture: Texture.EMPTY,\n                line: 0,\n                charCode: 0,\n                position: new Point(),\n            };\n            charRenderData.texture = charData.texture;\n            charRenderData.line = line;\n            charRenderData.charCode = charCode;\n            charRenderData.position.x = pos.x + charData.xOffset + (this._letterSpacing / 2);\n            charRenderData.position.y = pos.y + charData.yOffset;\n            chars.push(charRenderData);\n            pos.x += charData.xAdvance + this._letterSpacing;\n            lastLineWidth = pos.x;\n            maxLineHeight = Math.max(maxLineHeight, (charData.yOffset + charData.texture.height));\n            prevCharCode = charCode;\n            if (lastBreakPos !== -1 && maxWidth > 0 && pos.x > maxWidth) {\n                ++spacesRemoved;\n                removeItems(chars, 1 + lastBreakPos - spacesRemoved, 1 + i - lastBreakPos);\n                i = lastBreakPos;\n                lastBreakPos = -1;\n                lineWidths.push(lastBreakWidth);\n                maxLineWidth = Math.max(maxLineWidth, lastBreakWidth);\n                line++;\n                pos.x = 0;\n                pos.y += data.lineHeight;\n                prevCharCode = null;\n            }\n        }\n        var lastChar = text.charAt(text.length - 1);\n        if (lastChar !== '\\r' && lastChar !== '\\n') {\n            if ((/(?:\\s)/).test(lastChar)) {\n                lastLineWidth = lastBreakWidth;\n            }\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n        }\n        var lineAlignOffsets = [];\n        for (var i = 0; i <= line; i++) {\n            var alignOffset = 0;\n            if (this._align === 'right') {\n                alignOffset = maxLineWidth - lineWidths[i];\n            }\n            else if (this._align === 'center') {\n                alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n            }\n            lineAlignOffsets.push(alignOffset);\n        }\n        var lenChars = chars.length;\n        var pagesMeshData = {};\n        var newPagesMeshData = [];\n        var activePagesMeshData = this._activePagesMeshData;\n        for (var i = 0; i < activePagesMeshData.length; i++) {\n            pageMeshDataPool.push(activePagesMeshData[i]);\n        }\n        for (var i = 0; i < lenChars; i++) {\n            var texture = chars[i].texture;\n            var baseTextureUid = texture.baseTexture.uid;\n            if (!pagesMeshData[baseTextureUid]) {\n                var pageMeshData = pageMeshDataPool.pop();\n                if (!pageMeshData) {\n                    var geometry = new MeshGeometry();\n                    var material = new MeshMaterial(Texture.EMPTY);\n                    var mesh = new Mesh(geometry, material);\n                    pageMeshData = {\n                        index: 0,\n                        indexCount: 0,\n                        vertexCount: 0,\n                        uvsCount: 0,\n                        total: 0,\n                        mesh: mesh,\n                        vertices: null,\n                        uvs: null,\n                        indices: null,\n                    };\n                }\n                // reset data..\n                pageMeshData.index = 0;\n                pageMeshData.indexCount = 0;\n                pageMeshData.vertexCount = 0;\n                pageMeshData.uvsCount = 0;\n                pageMeshData.total = 0;\n                // TODO need to get page texture here somehow..\n                var _textureCache = this._textureCache;\n                _textureCache[baseTextureUid] = _textureCache[baseTextureUid] || new Texture(texture.baseTexture);\n                pageMeshData.mesh.texture = _textureCache[baseTextureUid];\n                pageMeshData.mesh.tint = this._tint;\n                newPagesMeshData.push(pageMeshData);\n                pagesMeshData[baseTextureUid] = pageMeshData;\n            }\n            pagesMeshData[baseTextureUid].total++;\n        }\n        // lets find any previously active pageMeshDatas that are no longer required for\n        // the updated text (if any), removed and return them to the pool.\n        for (var i = 0; i < activePagesMeshData.length; i++) {\n            if (newPagesMeshData.indexOf(activePagesMeshData[i]) === -1) {\n                this.removeChild(activePagesMeshData[i].mesh);\n            }\n        }\n        // next lets add any new meshes, that have not yet been added to this BitmapText\n        // we only add if its not already a child of this BitmapObject\n        for (var i = 0; i < newPagesMeshData.length; i++) {\n            if (newPagesMeshData[i].mesh.parent !== this) {\n                this.addChild(newPagesMeshData[i].mesh);\n            }\n        }\n        // active page mesh datas are set to be the new pages added.\n        this._activePagesMeshData = newPagesMeshData;\n        for (var i in pagesMeshData) {\n            var pageMeshData = pagesMeshData[i];\n            var total = pageMeshData.total;\n            // lets only allocate new buffers if we can fit the new text in the current ones..\n            // unless that is, we will be batching. Currently batching dose not respect the size property of mesh\n            if (!(((_a = pageMeshData.indices) === null || _a === void 0 ? void 0 : _a.length) > 6 * total) || pageMeshData.vertices.length < Mesh.BATCHABLE_SIZE * 2) {\n                pageMeshData.vertices = new Float32Array(4 * 2 * total);\n                pageMeshData.uvs = new Float32Array(4 * 2 * total);\n                pageMeshData.indices = new Uint16Array(6 * total);\n            }\n            else {\n                var total_1 = pageMeshData.total;\n                var vertices = pageMeshData.vertices;\n                // Clear the garbage at the end of the vertices buffer. This will prevent the bounds miscalculation.\n                for (var i_1 = total_1 * 4 * 2; i_1 < vertices.length; i_1++) {\n                    vertices[i_1] = 0;\n                }\n            }\n            // as a buffer maybe bigger than the current word, we set the size of the meshMaterial\n            // to match the number of letters needed\n            pageMeshData.mesh.size = 6 * total;\n        }\n        for (var i = 0; i < lenChars; i++) {\n            var char = chars[i];\n            var offset = char.position.x + lineAlignOffsets[char.line];\n            if (this._roundPixels) {\n                offset = Math.round(offset);\n            }\n            var xPos = offset * scale;\n            var yPos = char.position.y * scale;\n            var texture = char.texture;\n            var pageMesh = pagesMeshData[texture.baseTexture.uid];\n            var textureFrame = texture.frame;\n            var textureUvs = texture._uvs;\n            var index = pageMesh.index++;\n            pageMesh.indices[(index * 6) + 0] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 1] = 1 + (index * 4);\n            pageMesh.indices[(index * 6) + 2] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 3] = 0 + (index * 4);\n            pageMesh.indices[(index * 6) + 4] = 2 + (index * 4);\n            pageMesh.indices[(index * 6) + 5] = 3 + (index * 4);\n            pageMesh.vertices[(index * 8) + 0] = xPos;\n            pageMesh.vertices[(index * 8) + 1] = yPos;\n            pageMesh.vertices[(index * 8) + 2] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 3] = yPos;\n            pageMesh.vertices[(index * 8) + 4] = xPos + (textureFrame.width * scale);\n            pageMesh.vertices[(index * 8) + 5] = yPos + (textureFrame.height * scale);\n            pageMesh.vertices[(index * 8) + 6] = xPos;\n            pageMesh.vertices[(index * 8) + 7] = yPos + (textureFrame.height * scale);\n            pageMesh.uvs[(index * 8) + 0] = textureUvs.x0;\n            pageMesh.uvs[(index * 8) + 1] = textureUvs.y0;\n            pageMesh.uvs[(index * 8) + 2] = textureUvs.x1;\n            pageMesh.uvs[(index * 8) + 3] = textureUvs.y1;\n            pageMesh.uvs[(index * 8) + 4] = textureUvs.x2;\n            pageMesh.uvs[(index * 8) + 5] = textureUvs.y2;\n            pageMesh.uvs[(index * 8) + 6] = textureUvs.x3;\n            pageMesh.uvs[(index * 8) + 7] = textureUvs.y3;\n        }\n        this._textWidth = maxLineWidth * scale;\n        this._textHeight = (pos.y + data.lineHeight) * scale;\n        for (var i in pagesMeshData) {\n            var pageMeshData = pagesMeshData[i];\n            // apply anchor\n            if (this.anchor.x !== 0 || this.anchor.y !== 0) {\n                var vertexCount = 0;\n                var anchorOffsetX = this._textWidth * this.anchor.x;\n                var anchorOffsetY = this._textHeight * this.anchor.y;\n                for (var i_2 = 0; i_2 < pageMeshData.total; i_2++) {\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetX;\n                    pageMeshData.vertices[vertexCount++] -= anchorOffsetY;\n                }\n            }\n            this._maxLineHeight = maxLineHeight * scale;\n            var vertexBuffer = pageMeshData.mesh.geometry.getBuffer('aVertexPosition');\n            var textureBuffer = pageMeshData.mesh.geometry.getBuffer('aTextureCoord');\n            var indexBuffer = pageMeshData.mesh.geometry.getIndex();\n            vertexBuffer.data = pageMeshData.vertices;\n            textureBuffer.data = pageMeshData.uvs;\n            indexBuffer.data = pageMeshData.indices;\n            vertexBuffer.update();\n            textureBuffer.update();\n            indexBuffer.update();\n        }\n        for (var i = 0; i < chars.length; i++) {\n            charRenderDataPool.push(chars[i]);\n        }\n    };\n    /**\n     * Updates the transform of this object\n     *\n     * @private\n     */\n    BitmapText.prototype.updateTransform = function () {\n        this.validate();\n        this.containerUpdateTransform();\n    };\n    /**\n     * Validates text before calling parent's getLocalBounds\n     *\n     * @return {PIXI.Rectangle} The rectangular bounding area\n     */\n    BitmapText.prototype.getLocalBounds = function () {\n        this.validate();\n        return _super.prototype.getLocalBounds.call(this);\n    };\n    /**\n     * Updates text when needed\n     *\n     * @private\n     */\n    BitmapText.prototype.validate = function () {\n        if (this.dirty) {\n            this.updateText();\n            this.dirty = false;\n        }\n    };\n    Object.defineProperty(BitmapText.prototype, \"tint\", {\n        /**\n         * The tint of the BitmapText object.\n         *\n         * @member {number}\n         * @default 0xffffff\n         */\n        get: function () {\n            return this._tint;\n        },\n        set: function (value) {\n            if (this._tint === value)\n                { return; }\n            this._tint = value;\n            for (var i = 0; i < this._activePagesMeshData.length; i++) {\n                this._activePagesMeshData[i].mesh.tint = value;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"align\", {\n        /**\n         * The alignment of the BitmapText object.\n         *\n         * @member {string}\n         * @default 'left'\n         */\n        get: function () {\n            return this._align;\n        },\n        set: function (value) {\n            if (this._align !== value) {\n                this._align = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"fontName\", {\n        /**\n         * The name of the BitmapFont.\n         *\n         * @member {string}\n         */\n        get: function () {\n            return this._fontName;\n        },\n        set: function (value) {\n            if (!BitmapFont.available[value]) {\n                throw new Error(\"Missing BitmapFont \\\"\" + value + \"\\\"\");\n            }\n            if (this._fontName !== value) {\n                this._fontName = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"fontSize\", {\n        /**\n         * The size of the font to display.\n         *\n         * @member {number}\n         */\n        get: function () {\n            return this._fontSize;\n        },\n        set: function (value) {\n            if (this._fontSize !== value) {\n                this._fontSize = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"anchor\", {\n        /**\n         * The anchor sets the origin point of the text.\n         *\n         * The default is `(0,0)`, this means the text's origin is the top left.\n         *\n         * Setting the anchor to `(0.5,0.5)` means the text's origin is centered.\n         *\n         * Setting the anchor to `(1,1)` would mean the text's origin point will be the bottom right corner.\n         *\n         * @member {PIXI.Point | number}\n         */\n        get: function () {\n            return this._anchor;\n        },\n        set: function (value) {\n            if (typeof value === 'number') {\n                this._anchor.set(value);\n            }\n            else {\n                this._anchor.copyFrom(value);\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"text\", {\n        /**\n         * The text of the BitmapText object.\n         *\n         * @member {string}\n         */\n        get: function () {\n            return this._text;\n        },\n        set: function (text) {\n            text = String(text === null || text === undefined ? '' : text);\n            if (this._text === text) {\n                return;\n            }\n            this._text = text;\n            this.dirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"maxWidth\", {\n        /**\n         * The max width of this bitmap text in pixels. If the text provided is longer than the\n         * value provided, line breaks will be automatically inserted in the last whitespace.\n         * Disable by setting the value to 0.\n         *\n         * @member {number}\n         */\n        get: function () {\n            return this._maxWidth;\n        },\n        set: function (value) {\n            if (this._maxWidth === value) {\n                return;\n            }\n            this._maxWidth = value;\n            this.dirty = true;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"maxLineHeight\", {\n        /**\n         * The max line height. This is useful when trying to use the total height of the Text,\n         * i.e. when trying to vertically align.\n         *\n         * @member {number}\n         * @readonly\n         */\n        get: function () {\n            this.validate();\n            return this._maxLineHeight;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"textWidth\", {\n        /**\n         * The width of the overall text, different from fontSize,\n         * which is defined in the style object.\n         *\n         * @member {number}\n         * @readonly\n         */\n        get: function () {\n            this.validate();\n            return this._textWidth;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"letterSpacing\", {\n        /**\n         * Additional space between characters.\n         *\n         * @member {number}\n         */\n        get: function () {\n            return this._letterSpacing;\n        },\n        set: function (value) {\n            if (this._letterSpacing !== value) {\n                this._letterSpacing = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"roundPixels\", {\n        /**\n         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n         * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n         * The main disadvantage is movement of objects may appear less smooth.\n         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n         *\n         * @member {boolean}\n         * @default PIXI.settings.ROUND_PIXELS\n         */\n        get: function () {\n            return this._roundPixels;\n        },\n        set: function (value) {\n            if (value !== this._roundPixels) {\n                this._roundPixels = value;\n                this.dirty = true;\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(BitmapText.prototype, \"textHeight\", {\n        /**\n         * The height of the overall text, different from fontSize,\n         * which is defined in the style object.\n         *\n         * @member {number}\n         * @readonly\n         */\n        get: function () {\n            this.validate();\n            return this._textHeight;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * For backward compatibility, convert old style.font constructor param to fontName & fontSize properties.\n     *\n     * @private\n     * @deprecated since 5.3.0\n     */\n    BitmapText.prototype._upgradeStyle = function (style) {\n        if (typeof style.font === 'string') {\n            var valueSplit = style.font.split(' ');\n            style.fontName = valueSplit.length === 1\n                ? valueSplit[0]\n                : valueSplit.slice(1).join(' ');\n            if (valueSplit.length >= 2) {\n                style.fontSize = parseInt(valueSplit[0], 10);\n            }\n        }\n        else {\n            style.fontName = style.font.name;\n            style.fontSize = typeof style.font.size === 'number'\n                ? style.font.size\n                : parseInt(style.font.size, 10);\n        }\n    };\n    BitmapText.prototype.destroy = function (options) {\n        var _textureCache = this._textureCache;\n        for (var id in _textureCache) {\n            var texture = _textureCache[id];\n            texture.destroy();\n            delete _textureCache[id];\n        }\n        this._textureCache = null;\n        _super.prototype.destroy.call(this, options);\n    };\n    /**\n     * Register a bitmap font with data and a texture.\n     *\n     * @deprecated since 5.3.0\n     * @see PIXI.BitmapFont.install\n     * @static\n     */\n    BitmapText.registerFont = function (data, textures) {\n        deprecation('5.3.0', 'PIXI.BitmapText.registerFont is deprecated, use PIXI.BitmapFont.install');\n        return BitmapFont.install(data, textures);\n    };\n    Object.defineProperty(BitmapText, \"fonts\", {\n        /**\n         * Get the list of installed fonts.\n         *\n         * @see PIXI.BitmapFont.available\n         * @deprecated since 5.3.0\n         * @static\n         * @readonly\n         * @member {Object.<string, PIXI.BitmapFont>}\n         */\n        get: function () {\n            deprecation('5.3.0', 'PIXI.BitmapText.fonts is deprecated, use PIXI.BitmapFont.available');\n            return BitmapFont.available;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    BitmapText.styleDefaults = {\n        align: 'left',\n        tint: 0xFFFFFF,\n        maxWidth: 0,\n        letterSpacing: 0,\n    };\n    return BitmapText;\n}(Container));\n\n/**\n * {@link PIXI.Loader Loader} middleware for loading\n * bitmap-based fonts suitable for using with {@link PIXI.BitmapText}.\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nvar BitmapFontLoader = /** @class */ (function () {\n    function BitmapFontLoader() {\n    }\n    /**\n     * Called when the plugin is installed.\n     *\n     * @see PIXI.Loader.registerPlugin\n     */\n    BitmapFontLoader.add = function () {\n        LoaderResource.setExtensionXhrType('fnt', LoaderResource.XHR_RESPONSE_TYPE.TEXT);\n    };\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    BitmapFontLoader.use = function (resource, next) {\n        var format = autoDetectFormat(resource.data);\n        // Resource was not recognised as any of the expected font data format\n        if (!format) {\n            next();\n            return;\n        }\n        var baseUrl = BitmapFontLoader.getBaseUrl(this, resource);\n        var data = format.parse(resource.data);\n        var textures = {};\n        // Handle completed, when the number of textures\n        // load is the same number as references in the fnt file\n        var completed = function (page) {\n            textures[page.metadata.pageFile] = page.texture;\n            if (Object.keys(textures).length === data.page.length) {\n                resource.bitmapFont = BitmapFont.install(data, textures, true);\n                next();\n            }\n        };\n        for (var i = 0; i < data.page.length; ++i) {\n            var pageFile = data.page[i].file;\n            var url = baseUrl + pageFile;\n            var exists = false;\n            // incase the image is loaded outside\n            // using the same loader, resource will be available\n            for (var name in this.resources) {\n                var bitmapResource = this.resources[name];\n                if (bitmapResource.url === url) {\n                    bitmapResource.metadata.pageFile = pageFile;\n                    if (bitmapResource.texture) {\n                        completed(bitmapResource);\n                    }\n                    else {\n                        bitmapResource.onAfterMiddleware.add(completed);\n                    }\n                    exists = true;\n                    break;\n                }\n            }\n            // texture is not loaded, we'll attempt to add\n            // it to the load and add the texture to the list\n            if (!exists) {\n                // Standard loading options for images\n                var options = {\n                    crossOrigin: resource.crossOrigin,\n                    loadType: LoaderResource.LOAD_TYPE.IMAGE,\n                    metadata: Object.assign({ pageFile: pageFile }, resource.metadata.imageMetadata),\n                    parentResource: resource,\n                };\n                this.add(url, options, completed);\n            }\n        }\n    };\n    /**\n     * Get folder path from a resource\n     * @private\n     * @param {PIXI.Loader} loader\n     * @param {PIXI.LoaderResource} resource\n     * @return {string}\n     */\n    BitmapFontLoader.getBaseUrl = function (loader, resource) {\n        var resUrl = !resource.isDataUrl ? BitmapFontLoader.dirname(resource.url) : '';\n        if (resource.isDataUrl) {\n            if (resUrl === '.') {\n                resUrl = '';\n            }\n            if (loader.baseUrl && resUrl) {\n                // if baseurl has a trailing slash then add one to resUrl so the replace works below\n                if (loader.baseUrl.charAt(loader.baseUrl.length - 1) === '/') {\n                    resUrl += '/';\n                }\n            }\n        }\n        // remove baseUrl from resUrl\n        resUrl = resUrl.replace(loader.baseUrl, '');\n        // if there is an resUrl now, it needs a trailing slash. Ensure that it does if the string isn't empty.\n        if (resUrl && resUrl.charAt(resUrl.length - 1) !== '/') {\n            resUrl += '/';\n        }\n        return resUrl;\n    };\n    /**\n     * Replacement for NodeJS's path.dirname\n     * @private\n     * @param {string} url - Path to get directory for\n     */\n    BitmapFontLoader.dirname = function (url) {\n        var dir = url\n            .replace(/\\\\/g, '/') // convert windows notation to UNIX notation, URL-safe because it's a forbidden character\n            .replace(/\\/$/, '') // replace trailing slash\n            .replace(/\\/[^\\/]*$/, ''); // remove everything after the last\n        // File request is relative, use current directory\n        if (dir === url) {\n            return '.';\n        }\n        // Started with a slash\n        else if (dir === '') {\n            return '/';\n        }\n        return dir;\n    };\n    return BitmapFontLoader;\n}());\n\nexport { BitmapFont, BitmapFontData, BitmapFontLoader, BitmapText };\n//# sourceMappingURL=text-bitmap.es.js.map\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","BitmapFontData","this","info","common","page","char","kerning","TextFormat","test","data","indexOf","parse","txt","items","match","rawData","chars","kernings","i","name","attributeList","itemData","i_1","split","key","strValue","replace","floatValue","parseFloat","value","isNaN","push","font","forEach","face","size","parseInt","lineHeight","id","file","x","y","width","height","xoffset","yoffset","xadvance","first","second","amount","XMLFormat","XMLDocument","getElementsByTagName","length","getAttribute","xml","letter","XMLStringFormat","self","DOMParser","parseFromString","xmlTxt","window","formats","autoDetectFormat","generateFillStyle","canvas","context","style","resolution","lines","metrics","gradient","fillStyle","fill","isArray","dropShadowCorrection","dropShadowDistance","padding","Math","ceil","slice","fillGradientStops","lengthPlus1","unshift","fillGradientType","createLinearGradient","lastIterationStop","gradStopLineHeight","fontProperties","fontSize","strokeThickness","thisLineTop","j","globalStop","clampedStop","max","min","addColorStop","totalIterations","currentIteration","stop","drawGlyph","text","translate","scale","tx","ty","toFontString","lineWidth","textBaseline","lineJoin","miterLimit","strokeStyle","stroke","dropShadowColor","rgb","hex2rgb","string2hex","dropShadow","shadowColor","dropShadowAlpha","shadowBlur","dropShadowBlur","shadowOffsetX","cos","dropShadowAngle","shadowOffsetY","sin","strokeText","descent","fillText","setTransform","BitmapFont","textures","ownsTextures","res","getResolutionOfUrl","pageTextures","_ownsTextures","_a","_b","page_1","_c","rect","frame","xOffset","yOffset","xAdvance","texture","baseTexture","_d","prototype","destroy","install","fontData","format","Error","available","uninstall","from","textStyle","options","assign","defaultOptions","textureWidth","textureHeight","charsList","result","item","startCode","charCodeAt","endCode","j_1","String","fromCharCode","apply","resolveCharacters","fontFamily","positionX","positionY","maxCharHeight","document","createElement","getContext","textureGlyphWidth","fontStyle","undefined","ALPHA","NUMERIC","ALPHANUMERIC","ASCII","pageMeshDataPool","charRenderDataPool","BitmapText","_super","_this","call","_tint","deprecation","_upgradeStyle","styleDefaults","align","tint","maxWidth","letterSpacing","fontName","_activePagesMeshData","_textWidth","_textHeight","_align","_fontName","_fontSize","_text","_maxWidth","_maxLineHeight","_letterSpacing","_anchor","dirty","_roundPixels","_textureCache","__","constructor","create","__extends","updateText","pos","lineWidths","textLength","prevCharCode","lastLineWidth","maxLineWidth","line","lastBreakPos","lastBreakWidth","spacesRemoved","maxLineHeight","charCode","charAt","charData","charRenderData","pop","position","removeItems","lastChar","lineAlignOffsets","alignOffset","lenChars","pagesMeshData","newPagesMeshData","activePagesMeshData","baseTextureUid","uid","pageMeshData","geometry","material","index","indexCount","vertexCount","uvsCount","total","mesh","vertices","uvs","indices","removeChild","parent","addChild","Float32Array","Uint16Array","total_1","offset","round","xPos","yPos","pageMesh","textureFrame","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","anchor","anchorOffsetX","anchorOffsetY","i_2","vertexBuffer","getBuffer","textureBuffer","indexBuffer","getIndex","update","updateTransform","validate","containerUpdateTransform","getLocalBounds","defineProperty","get","set","enumerable","configurable","copyFrom","valueSplit","join","registerFont","BitmapFontLoader","add","use","resource","next","baseUrl","getBaseUrl","completed","metadata","pageFile","keys","bitmapFont","url","exists","resources","bitmapResource","onAfterMiddleware","crossOrigin","loadType","imageMetadata","parentResource","loader","resUrl","isDataUrl","dirname","dir"],"sourceRoot":""}