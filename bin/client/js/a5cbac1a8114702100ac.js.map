{"version":3,"file":"js/a5cbac1a8114702100ac.js","mappings":"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","sources":["webpack:///../../node_modules/@pixi/sprite-tiling/lib/sprite-tiling.es.js"],"sourcesContent":["/*!\n * @pixi/sprite-tiling - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/sprite-tiling is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { TextureMatrix, Texture, Shader, QuadUv, State, ObjectRenderer } from '@pixi/core';\nimport { Point, Transform, Rectangle, Matrix } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { deprecation, premultiplyTintToRgba, correctBlendMode } from '@pixi/utils';\nimport { WRAP_MODES } from '@pixi/constants';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar tempPoint = new Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nvar TilingSprite = /** @class */ (function (_super) {\n    __extends(TilingSprite, _super);\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    function TilingSprite(texture, width, height) {\n        if (width === void 0) { width = 100; }\n        if (height === void 0) { height = 100; }\n        var _this = _super.call(this, texture) || this;\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.Transform}\n         */\n        _this.tileTransform = new Transform();\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        _this._width = width;\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        _this._height = height;\n        /**\n         * matrix that is applied to UV to get the coords in Texture normalized space to coords in BaseTexture space\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        _this.uvMatrix = _this.texture.uvMatrix || new TextureMatrix(texture);\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        _this.pluginName = 'tilingSprite';\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        _this.uvRespectAnchor = false;\n        return _this;\n    }\n    Object.defineProperty(TilingSprite.prototype, \"clampMargin\", {\n        /**\n         * Changes frame clamping in corresponding textureTransform, shortcut\n         * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n         *\n         * @default 0.5\n         * @member {number}\n         */\n        get: function () {\n            return this.uvMatrix.clampMargin;\n        },\n        set: function (value) {\n            this.uvMatrix.clampMargin = value;\n            this.uvMatrix.update(true);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TilingSprite.prototype, \"tileScale\", {\n        /**\n         * The scaling of the image that is being tiled\n         *\n         * @member {PIXI.ObservablePoint}\n         */\n        get: function () {\n            return this.tileTransform.scale;\n        },\n        set: function (value) {\n            this.tileTransform.scale.copyFrom(value);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TilingSprite.prototype, \"tilePosition\", {\n        /**\n         * The offset of the image that is being tiled\n         *\n         * @member {PIXI.ObservablePoint}\n         */\n        get: function () {\n            return this.tileTransform.position;\n        },\n        set: function (value) {\n            this.tileTransform.position.copyFrom(value);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * @protected\n     */\n    TilingSprite.prototype._onTextureUpdate = function () {\n        if (this.uvMatrix) {\n            this.uvMatrix.texture = this._texture;\n        }\n        this._cachedTint = 0xFFFFFF;\n    };\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @protected\n     * @param {PIXI.Renderer} renderer - The renderer\n     */\n    TilingSprite.prototype._render = function (renderer) {\n        // tweak our texture temporarily..\n        var texture = this._texture;\n        if (!texture || !texture.valid) {\n            return;\n        }\n        this.tileTransform.updateLocalTransform();\n        this.uvMatrix.update();\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    };\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @protected\n     */\n    TilingSprite.prototype._calculateBounds = function () {\n        var minX = this._width * -this._anchor._x;\n        var minY = this._height * -this._anchor._y;\n        var maxX = this._width * (1 - this._anchor._x);\n        var maxY = this._height * (1 - this._anchor._y);\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    };\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    TilingSprite.prototype.getLocalBounds = function (rect) {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0) {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._y);\n            if (!rect) {\n                if (!this._localBoundsRect) {\n                    this._localBoundsRect = new Rectangle();\n                }\n                rect = this._localBoundsRect;\n            }\n            return this._bounds.getRectangle(rect);\n        }\n        return _super.prototype.getLocalBounds.call(this, rect);\n    };\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.IPointData} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    TilingSprite.prototype.containsPoint = function (point) {\n        this.worldTransform.applyInverse(point, tempPoint);\n        var width = this._width;\n        var height = this._height;\n        var x1 = -width * this.anchor._x;\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n            var y1 = -height * this.anchor._y;\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    TilingSprite.prototype.destroy = function (options) {\n        _super.prototype.destroy.call(this, options);\n        this.tileTransform = null;\n        this.uvMatrix = null;\n    };\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {Object} options - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @param {number} options.width - required width of the tiling sprite\n     * @param {number} options.height - required height of the tiling sprite\n     * @return {PIXI.TilingSprite} The newly created texture\n     */\n    TilingSprite.from = function (source, options) {\n        // Deprecated\n        if (typeof options === 'number') {\n            deprecation('5.3.0', 'TilingSprite.from use options instead of width and height args');\n            // eslint-disable-next-line prefer-rest-params\n            options = { width: options, height: arguments[2] };\n        }\n        return new TilingSprite(Texture.from(source, options), options.width, options.height);\n    };\n    Object.defineProperty(TilingSprite.prototype, \"width\", {\n        /**\n         * The width of the sprite, setting this will actually modify the scale to achieve the value set\n         *\n         * @member {number}\n         */\n        get: function () {\n            return this._width;\n        },\n        set: function (value) {\n            this._width = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TilingSprite.prototype, \"height\", {\n        /**\n         * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n         *\n         * @member {number}\n         */\n        get: function () {\n            return this._height;\n        },\n        set: function (value) {\n            this._height = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return TilingSprite;\n}(Sprite));\n\nvar vertex = \"attribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nuniform mat3 translationMatrix;\\nuniform mat3 uTransform;\\n\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void)\\n{\\n    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n\\n    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;\\n}\\n\";\n\nvar fragment = \"varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\nuniform mat3 uMapCoord;\\nuniform vec4 uClampFrame;\\nuniform vec2 uClampOffset;\\n\\nvoid main(void)\\n{\\n    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);\\n    coord = (uMapCoord * vec3(coord, 1.0)).xy;\\n    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);\\n\\n    vec4 texSample = texture2D(uSampler, coord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\n\nvar fragmentSimple = \"varying vec2 vTextureCoord;\\n\\nuniform sampler2D uSampler;\\nuniform vec4 uColor;\\n\\nvoid main(void)\\n{\\n    vec4 texSample = texture2D(uSampler, vTextureCoord);\\n    gl_FragColor = texSample * uColor;\\n}\\n\";\n\nvar tempMat = new Matrix();\n/**\n * WebGL renderer plugin for tiling sprites\n *\n * @class\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n */\nvar TilingSpriteRenderer = /** @class */ (function (_super) {\n    __extends(TilingSpriteRenderer, _super);\n    /**\n     * constructor for renderer\n     *\n     * @param {PIXI.Renderer} renderer - The renderer this tiling awesomeness works for.\n     */\n    function TilingSpriteRenderer(renderer) {\n        var _this = _super.call(this, renderer) || this;\n        var uniforms = { globals: _this.renderer.globalUniforms };\n        _this.shader = Shader.from(vertex, fragment, uniforms);\n        _this.simpleShader = Shader.from(vertex, fragmentSimple, uniforms);\n        _this.quad = new QuadUv();\n        /**\n         * The WebGL state in which this renderer will work.\n         *\n         * @member {PIXI.State}\n         * @readonly\n         */\n        _this.state = State.for2d();\n        return _this;\n    }\n    /**\n     *\n     * @param {PIXI.TilingSprite} ts - tilingSprite to be rendered\n     */\n    TilingSpriteRenderer.prototype.render = function (ts) {\n        var renderer = this.renderer;\n        var quad = this.quad;\n        var vertices = quad.vertices;\n        vertices[0] = vertices[6] = (ts._width) * -ts.anchor.x;\n        vertices[1] = vertices[3] = ts._height * -ts.anchor.y;\n        vertices[2] = vertices[4] = (ts._width) * (1.0 - ts.anchor.x);\n        vertices[5] = vertices[7] = ts._height * (1.0 - ts.anchor.y);\n        if (ts.uvRespectAnchor) {\n            vertices = quad.uvs;\n            vertices[0] = vertices[6] = -ts.anchor.x;\n            vertices[1] = vertices[3] = -ts.anchor.y;\n            vertices[2] = vertices[4] = 1.0 - ts.anchor.x;\n            vertices[5] = vertices[7] = 1.0 - ts.anchor.y;\n        }\n        quad.invalidate();\n        var tex = ts._texture;\n        var baseTex = tex.baseTexture;\n        var lt = ts.tileTransform.localTransform;\n        var uv = ts.uvMatrix;\n        var isSimple = baseTex.isPowerOfTwo\n            && tex.frame.width === baseTex.width && tex.frame.height === baseTex.height;\n        // auto, force repeat wrapMode for big tiling textures\n        if (isSimple) {\n            if (!baseTex._glTextures[renderer.CONTEXT_UID]) {\n                if (baseTex.wrapMode === WRAP_MODES.CLAMP) {\n                    baseTex.wrapMode = WRAP_MODES.REPEAT;\n                }\n            }\n            else {\n                isSimple = baseTex.wrapMode !== WRAP_MODES.CLAMP;\n            }\n        }\n        var shader = isSimple ? this.simpleShader : this.shader;\n        var w = tex.width;\n        var h = tex.height;\n        var W = ts._width;\n        var H = ts._height;\n        tempMat.set(lt.a * w / W, lt.b * w / H, lt.c * h / W, lt.d * h / H, lt.tx / W, lt.ty / H);\n        // that part is the same as above:\n        // tempMat.identity();\n        // tempMat.scale(tex.width, tex.height);\n        // tempMat.prepend(lt);\n        // tempMat.scale(1.0 / ts._width, 1.0 / ts._height);\n        tempMat.invert();\n        if (isSimple) {\n            tempMat.prepend(uv.mapCoord);\n        }\n        else {\n            shader.uniforms.uMapCoord = uv.mapCoord.toArray(true);\n            shader.uniforms.uClampFrame = uv.uClampFrame;\n            shader.uniforms.uClampOffset = uv.uClampOffset;\n        }\n        shader.uniforms.uTransform = tempMat.toArray(true);\n        shader.uniforms.uColor = premultiplyTintToRgba(ts.tint, ts.worldAlpha, shader.uniforms.uColor, baseTex.alphaMode);\n        shader.uniforms.translationMatrix = ts.transform.worldTransform.toArray(true);\n        shader.uniforms.uSampler = tex;\n        renderer.shader.bind(shader);\n        renderer.geometry.bind(quad);\n        this.state.blendMode = correctBlendMode(ts.blendMode, baseTex.alphaMode);\n        renderer.state.set(this.state);\n        renderer.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0);\n    };\n    return TilingSpriteRenderer;\n}(ObjectRenderer));\n\nexport { TilingSprite, TilingSpriteRenderer };\n//# sourceMappingURL=sprite-tiling.es.js.map\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","tempPoint","TilingSprite","_super","texture","width","height","_this","call","tileTransform","_width","_height","uvMatrix","pluginName","uvRespectAnchor","defineProperty","get","clampMargin","set","value","update","enumerable","configurable","scale","copyFrom","position","_onTextureUpdate","_texture","_cachedTint","_render","renderer","valid","updateLocalTransform","batch","setObjectRenderer","plugins","render","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","transform","getLocalBounds","rect","children","length","_localBoundsRect","getRectangle","containsPoint","point","worldTransform","applyInverse","x1","anchor","x","y1","y","destroy","options","from","source","deprecation","arguments","vertex","tempMat","TilingSpriteRenderer","uniforms","globals","globalUniforms","shader","simpleShader","quad","state","ts","vertices","uvs","invalidate","tex","baseTex","baseTexture","lt","localTransform","uv","isSimple","isPowerOfTwo","frame","_glTextures","CONTEXT_UID","wrapMode","w","h","W","H","a","c","tx","ty","invert","prepend","mapCoord","uMapCoord","toArray","uClampFrame","uClampOffset","uTransform","uColor","premultiplyTintToRgba","tint","worldAlpha","alphaMode","translationMatrix","uSampler","bind","geometry","blendMode","correctBlendMode","draw","gl","TRIANGLES"],"sourceRoot":""}