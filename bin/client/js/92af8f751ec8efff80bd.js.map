{"version":3,"file":"js/92af8f751ec8efff80bd.js","mappings":"oFAaa,EAAQ,OAgBWA,EAdjB,EAAQ,QAc8BA,EAAIC,WAvBzD,IAuBgCD,EAR5BE,EAMJ,SAAiCF,GAAO,GAAIA,GAAOA,EAAIC,WAAc,OAAOD,EAAc,IAAIG,EAAS,GAAI,GAAW,MAAPH,EAAe,IAAK,IAAII,KAAOJ,EAAWK,OAAOC,UAAUC,eAAeC,KAAKR,EAAKI,KAAMD,EAAOC,GAAOJ,EAAII,IAAgC,OAAtBD,EAAOM,QAAUT,EAAYG,EANvPO,CAFC,EAAQ,OAIpB,EAAQ,MAEU,EAAQ,MAM1BR,EAAKS,SAASC,kCAAmC,EACjDV,EAAKW,MAAMC,YACMZ,EAAKa,OAAOC","sources":["webpack:///../../node_modules/react-leaflet-pixi-overlay/build/PixiOverlay.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n//leaflet\n\n\n//pixi-overlay\n\n\nvar _react = require('react');\n\nvar _leaflet = require('leaflet');\n\nvar _leaflet2 = _interopRequireDefault(_leaflet);\n\nvar _pixi = require('pixi.js');\n\nvar PIXI = _interopRequireWildcard(_pixi);\n\nrequire('leaflet-pixi-overlay');\n\nvar _useLeaflet = require('use-leaflet');\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nPIXI.settings.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = false;\nPIXI.utils.skipHello();\nvar PIXILoader = PIXI.Loader.shared;\n\nvar PixiOverlay = function PixiOverlay(_ref) {\n\tvar markers = _ref.markers;\n\n\tvar _useState = (0, _react.useState)(null),\n\t    _useState2 = _slicedToArray(_useState, 2),\n\t    openedPopupData = _useState2[0],\n\t    setOpenedPopupData = _useState2[1];\n\n\tvar _useState3 = (0, _react.useState)(null),\n\t    _useState4 = _slicedToArray(_useState3, 2),\n\t    openedTooltipData = _useState4[0],\n\t    setOpenedTooltipData = _useState4[1];\n\n\tvar _useState5 = (0, _react.useState)(null),\n\t    _useState6 = _slicedToArray(_useState5, 2),\n\t    openedPopup = _useState6[0],\n\t    setOpenedPopup = _useState6[1];\n\n\tvar _useState7 = (0, _react.useState)(null),\n\t    _useState8 = _slicedToArray(_useState7, 2),\n\t    openedTooltip = _useState8[0],\n\t    setOpenedTooltip = _useState8[1];\n\n\tvar _useState9 = (0, _react.useState)(null),\n\t    _useState10 = _slicedToArray(_useState9, 2),\n\t    pixiOverlay = _useState10[0],\n\t    setPixiOverlay = _useState10[1];\n\n\tvar _useState11 = (0, _react.useState)(false),\n\t    _useState12 = _slicedToArray(_useState11, 2),\n\t    loaded = _useState12[0],\n\t    setLoaded = _useState12[1];\n\n\tvar map = (0, _useLeaflet.useLeafletMap)();\n\n\t// load sprites\n\t(0, _react.useEffect)(function () {\n\t\t// cancel loading if already loading as it may cause: Error: Cannot add resources while the loader is running.\n\t\tif (PIXILoader.loading) {\n\t\t\tPIXILoader.reset();\n\t\t}\n\n\t\tvar loadingAny = false;\n\t\tvar _iteratorNormalCompletion = true;\n\t\tvar _didIteratorError = false;\n\t\tvar _iteratorError = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator = markers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\t\tvar marker = _step.value;\n\n\t\t\t\tvar resolvedMarkerId = marker.iconId || marker.iconColor;\n\n\t\t\t\t// skip if no ID or already cached\n\t\t\t\tif (!marker.iconColor && !marker.iconId || PIXILoader.resources['marker_' + resolvedMarkerId]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tloadingAny = true;\n\n\t\t\t\tPIXILoader.add('marker_' + resolvedMarkerId, marker.customIcon ? getEncodedIcon(marker.customIcon) : getDefaultIcon(marker.iconColor));\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError = true;\n\t\t\t_iteratorError = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t\t_iterator.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError) {\n\t\t\t\t\tthrow _iteratorError;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (loaded && loadingAny) {\n\t\t\tsetLoaded(false);\n\t\t}\n\n\t\tif (loadingAny) {\n\t\t\tPIXILoader.load(function () {\n\t\t\t\treturn setLoaded(true);\n\t\t\t});\n\t\t} else {\n\t\t\tsetLoaded(true);\n\t\t}\n\t}, [markers]);\n\n\t// load pixi when map changes\n\t(0, _react.useEffect)(function () {\n\t\tvar pixiContainer = new PIXI.Container();\n\t\tvar overlay = _leaflet2.default.pixiOverlay(function (utils) {\n\t\t\t// redraw markers\n\t\t\tvar scale = utils.getScale();\n\t\t\tutils.getContainer().children.forEach(function (child) {\n\t\t\t\treturn child.scale.set(1 / scale);\n\t\t\t});\n\n\t\t\tutils.getRenderer().render(utils.getContainer());\n\t\t}, pixiContainer);\n\t\toverlay.addTo(map);\n\t\tsetPixiOverlay(overlay);\n\n\t\tsetOpenedPopupData(null);\n\t\tsetOpenedTooltipData(null);\n\n\t\treturn function () {\n\t\t\treturn pixiContainer.removeChildren();\n\t\t};\n\t}, [map]);\n\n\t// draw markers first time in new container\n\t(0, _react.useEffect)(function () {\n\t\tif (pixiOverlay && markers && loaded) {\n\t\t\tvar utils = pixiOverlay.utils;\n\t\t\tvar container = utils.getContainer();\n\t\t\tvar renderer = utils.getRenderer();\n\t\t\tvar project = utils.latLngToLayerPoint;\n\t\t\tvar scale = utils.getScale();\n\n\t\t\tmarkers.forEach(function (marker) {\n\t\t\t\tvar id = marker.id,\n\t\t\t\t    iconColor = marker.iconColor,\n\t\t\t\t    iconId = marker.iconId,\n\t\t\t\t    onClick = marker.onClick,\n\t\t\t\t    position = marker.position,\n\t\t\t\t    popup = marker.popup,\n\t\t\t\t    tooltip = marker.tooltip,\n\t\t\t\t    popupOpen = marker.popupOpen,\n\t\t\t\t    markerSpriteAnchor = marker.markerSpriteAnchor;\n\n\n\t\t\t\tvar resolvedIconId = iconId || iconColor;\n\n\t\t\t\tif (!PIXILoader.resources['marker_' + resolvedIconId] || !PIXILoader.resources['marker_' + resolvedIconId].texture) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar markerTexture = PIXILoader.resources['marker_' + resolvedIconId].texture;\n\t\t\t\t//const markerTexture = new PIXI.Texture.fromImage(url);\n\n\t\t\t\tmarkerTexture.anchor = { x: 0.5, y: 1 };\n\n\t\t\t\tvar markerSprite = PIXI.Sprite.from(markerTexture);\n\t\t\t\tif (markerSpriteAnchor) {\n\t\t\t\t\tmarkerSprite.anchor.set(markerSpriteAnchor[0], markerSpriteAnchor[1]);\n\t\t\t\t} else {\n\t\t\t\t\tmarkerSprite.anchor.set(0.5, 1);\n\t\t\t\t}\n\n\t\t\t\tvar markerCoords = project(position);\n\t\t\t\tmarkerSprite.x = markerCoords.x;\n\t\t\t\tmarkerSprite.y = markerCoords.y;\n\n\t\t\t\tmarkerSprite.scale.set(1 / scale);\n\n\t\t\t\tif (popupOpen) {\n\t\t\t\t\tsetOpenedPopupData({\n\t\t\t\t\t\tid: id,\n\t\t\t\t\t\toffset: [0, -35],\n\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\tcontent: popup,\n\t\t\t\t\t\tonClick: onClick\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (popup || onClick || tooltip) {\n\t\t\t\t\tmarkerSprite.interactive = true;\n\t\t\t\t}\n\n\t\t\t\tif (popup || onClick) {\n\t\t\t\t\t// Prevent accidental launch of onClick event when dragging the map.\n\t\t\t\t\t// Detect very small moves as clicks.\n\t\t\t\t\tmarkerSprite.on('mousedown', function () {\n\t\t\t\t\t\tvar moveCount = 0;\n\t\t\t\t\t\tmarkerSprite.on('mousemove', function () {\n\t\t\t\t\t\t\tmoveCount++;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmarkerSprite.on('mouseup', function () {\n\t\t\t\t\t\t\tif (moveCount < 2 && onClick) {\n\t\t\t\t\t\t\t\tonClick(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t\t// Prevent the same thing on touch devices.\n\t\t\t\t\tmarkerSprite.on('touchstart', function () {\n\t\t\t\t\t\tvar moveCount = 0;\n\t\t\t\t\t\tmarkerSprite.on('touchmove', function () {\n\t\t\t\t\t\t\tmoveCount++;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tmarkerSprite.on('touchend', function () {\n\t\t\t\t\t\t\tif (moveCount < 10 && onClick) {\n\t\t\t\t\t\t\t\tonClick(id);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tmarkerSprite.defaultCursor = 'pointer';\n\t\t\t\t\tmarkerSprite.buttonMode = true;\n\t\t\t\t}\n\n\t\t\t\tif (tooltip) {\n\t\t\t\t\tmarkerSprite.on('mouseover', function () {\n\t\t\t\t\t\tsetOpenedTooltipData({\n\t\t\t\t\t\t\tid: id,\n\t\t\t\t\t\t\toffset: [0, -35],\n\t\t\t\t\t\t\tposition: position,\n\t\t\t\t\t\t\tcontent: tooltip\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\tmarkerSprite.on('mouseout', function () {\n\t\t\t\t\t\tsetOpenedTooltipData(null);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tcontainer.addChild(markerSprite);\n\t\t\t});\n\n\t\t\trenderer.render(container);\n\t\t}\n\n\t\treturn function () {\n\t\t\treturn pixiOverlay && pixiOverlay.utils.getContainer().removeChildren();\n\t\t};\n\t}, [pixiOverlay, markers, loaded]);\n\n\t// handle tooltip\n\t(0, _react.useEffect)(function () {\n\t\tif (openedTooltip) {\n\t\t\tmap.closePopup(openedTooltip);\n\t\t}\n\n\t\tif (openedTooltipData && (!openedPopup || !openedPopupData || openedPopupData.id !== openedTooltipData.id)) {\n\t\t\tsetOpenedTooltip(openPopup(map, openedTooltipData));\n\t\t}\n\n\t\t// we don't want to reload when openedTooltip changes as we'd get a loop\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [openedTooltipData, openedPopupData, map]);\n\n\t// handle popup\n\t(0, _react.useEffect)(function () {\n\t\t// close only if different popup\n\t\tif (openedPopup) {\n\t\t\tmap.closePopup(openedPopup);\n\t\t}\n\n\t\t// open only if new popup\n\t\tif (openedPopupData) {\n\t\t\tsetOpenedPopup(openPopup(map, openedPopupData, { autoClose: false }, true));\n\t\t}\n\n\t\t// we don't want to reload when whenedPopup changes as we'd get a loop\n\t\t// eslint-disable-next-line react-hooks/exhaustive-deps\n\t}, [openedPopupData, map]);\n\n\treturn null;\n};\n\nfunction openPopup(map, data) {\n\tvar extraOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\tvar isPopup = arguments[3];\n\n\tvar popup = _leaflet2.default.popup(Object.assign({ offset: data.offset }, extraOptions)).setLatLng(data.position).setContent(data.content).openOn(map);\n\n\t// TODO don't call onClick if opened a new one\n\tif (isPopup && data.onClick) {\n\t\tpopup.on('remove', function () {\n\t\t\tdata.onClick(null);\n\t\t});\n\t}\n\n\treturn popup;\n}\n\nfunction getDefaultIcon(color) {\n\tvar svgIcon = '<svg style=\"-webkit-filter: drop-shadow( 1px 1px 1px rgba(0, 0, 0, .4));filter: drop-shadow( 1px 1px 1px rgba(0, 0, 0, .4));\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"' + color + '\" width=\"36\" height=\"36\" viewBox=\"0 0 24 24\"><path d=\"M12 0c-4.198 0-8 3.403-8 7.602 0 6.243 6.377 6.903 8 16.398 1.623-9.495 8-10.155 8-16.398 0-4.199-3.801-7.602-8-7.602zm0 11c-1.657 0-3-1.343-3-3s1.342-3 3-3 3 1.343 3 3-1.343 3-3 3z\"/></svg>';\n\treturn getEncodedIcon(svgIcon);\n}\n\nfunction getEncodedIcon(svg) {\n\tvar decoded = unescape(encodeURIComponent(svg));\n\tvar base64 = btoa(decoded);\n\treturn 'data:image/svg+xml;base64,' + base64;\n}\n\nexports.default = PixiOverlay;"],"names":["obj","__esModule","PIXI","newObj","key","Object","prototype","hasOwnProperty","call","default","_interopRequireWildcard","settings","FAIL_IF_MAJOR_PERFORMANCE_CAVEAT","utils","skipHello","Loader","shared"],"sourceRoot":""}