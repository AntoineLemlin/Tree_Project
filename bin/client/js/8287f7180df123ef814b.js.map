{"version":3,"file":"js/8287f7180df123ef814b.js","mappings":"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","sources":["webpack:///../../node_modules/@pixi/spritesheet/lib/spritesheet.es.js"],"sourcesContent":["/*!\n * @pixi/spritesheet - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/spritesheet is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Rectangle } from '@pixi/math';\nimport { Texture, BaseTexture } from '@pixi/core';\nimport { getResolutionOfUrl, url } from '@pixi/utils';\nimport { LoaderResource } from '@pixi/loaders';\n\n/**\n * Utility class for maintaining reference to a collection\n * of Textures on a single Spritesheet.\n *\n * To access a sprite sheet from your code pass its JSON data file to Pixi's loader:\n *\n * ```js\n * PIXI.Loader.shared.add(\"images/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"images/spritesheet.json\"].spritesheet;\n *   ...\n * }\n * ```\n * With the `sheet.textures` you can create Sprite objects,`sheet.animations` can be used to create an AnimatedSprite.\n *\n * Sprite sheets can be packed using tools like {@link https://codeandweb.com/texturepacker|TexturePacker},\n * {@link https://renderhjs.net/shoebox/|Shoebox} or {@link https://github.com/krzysztof-o/spritesheet.js|Spritesheet.js}.\n * Default anchor points (see {@link PIXI.Texture#defaultAnchor}) and grouping of animation sprites are currently only\n * supported by TexturePacker.\n *\n * @class\n * @memberof PIXI\n */\nvar Spritesheet = /** @class */ (function () {\n    /**\n     * @param {PIXI.BaseTexture|PIXI.Texture} baseTexture - Reference to the source BaseTexture object.\n     * @param {Object} data - Spritesheet image data.\n     * @param {string} [resolutionFilename] - The filename to consider when determining\n     *        the resolution of the spritesheet. If not provided, the imageUrl will\n     *        be used on the BaseTexture.\n     */\n    function Spritesheet(texture, data, resolutionFilename) {\n        if (resolutionFilename === void 0) { resolutionFilename = null; }\n        /**\n         * Reference to original source image from the Loader. This reference is retained so we\n         * can destroy the Texture later on. It is never used internally.\n         * @type {PIXI.Texture}\n         * @private\n         */\n        this._texture = texture instanceof Texture ? texture : null;\n        /**\n         * Reference to ths source texture.\n         * @type {PIXI.BaseTexture}\n         */\n        this.baseTexture = texture instanceof BaseTexture ? texture : this._texture.baseTexture;\n        /**\n         * A map containing all textures of the sprite sheet.\n         * Can be used to create a {@link PIXI.Sprite|Sprite}:\n         * ```js\n         * new PIXI.Sprite(sheet.textures[\"image.png\"]);\n         * ```\n         * @member {Object}\n         */\n        this.textures = {};\n        /**\n         * A map containing the textures for each animation.\n         * Can be used to create an {@link PIXI.AnimatedSprite|AnimatedSprite}:\n         * ```js\n         * new PIXI.AnimatedSprite(sheet.animations[\"anim_name\"])\n         * ```\n         * @member {Object}\n         */\n        this.animations = {};\n        /**\n         * Reference to the original JSON data.\n         * @type {Object}\n         */\n        this.data = data;\n        var resource = this.baseTexture.resource;\n        /**\n         * The resolution of the spritesheet.\n         * @type {number}\n         */\n        this.resolution = this._updateResolution(resolutionFilename || (resource ? resource.url : null));\n        /**\n         * Map of spritesheet frames.\n         * @type {Object}\n         * @private\n         */\n        this._frames = this.data.frames;\n        /**\n         * Collection of frame names.\n         * @type {string[]}\n         * @private\n         */\n        this._frameKeys = Object.keys(this._frames);\n        /**\n         * Current batch index being processed.\n         * @type {number}\n         * @private\n         */\n        this._batchIndex = 0;\n        /**\n         * Callback when parse is completed.\n         * @type {Function}\n         * @private\n         */\n        this._callback = null;\n    }\n    /**\n     * Generate the resolution from the filename or fallback\n     * to the meta.scale field of the JSON data.\n     *\n     * @private\n     * @param {string} resolutionFilename - The filename to use for resolving\n     *        the default resolution.\n     * @return {number} Resolution to use for spritesheet.\n     */\n    Spritesheet.prototype._updateResolution = function (resolutionFilename) {\n        if (resolutionFilename === void 0) { resolutionFilename = null; }\n        var scale = this.data.meta.scale;\n        // Use a defaultValue of `null` to check if a url-based resolution is set\n        var resolution = getResolutionOfUrl(resolutionFilename, null);\n        // No resolution found via URL\n        if (resolution === null) {\n            // Use the scale value or default to 1\n            resolution = scale !== undefined ? parseFloat(scale) : 1;\n        }\n        // For non-1 resolutions, update baseTexture\n        if (resolution !== 1) {\n            this.baseTexture.setResolution(resolution);\n        }\n        return resolution;\n    };\n    /**\n     * Parser spritesheet from loaded data. This is done asynchronously\n     * to prevent creating too many Texture within a single process.\n     *\n     * @param {Function} callback - Callback when complete returns\n     *        a map of the Textures for this spritesheet.\n     */\n    Spritesheet.prototype.parse = function (callback) {\n        this._batchIndex = 0;\n        this._callback = callback;\n        if (this._frameKeys.length <= Spritesheet.BATCH_SIZE) {\n            this._processFrames(0);\n            this._processAnimations();\n            this._parseComplete();\n        }\n        else {\n            this._nextBatch();\n        }\n    };\n    /**\n     * Process a batch of frames\n     *\n     * @private\n     * @param {number} initialFrameIndex - The index of frame to start.\n     */\n    Spritesheet.prototype._processFrames = function (initialFrameIndex) {\n        var frameIndex = initialFrameIndex;\n        var maxFrames = Spritesheet.BATCH_SIZE;\n        while (frameIndex - initialFrameIndex < maxFrames && frameIndex < this._frameKeys.length) {\n            var i = this._frameKeys[frameIndex];\n            var data = this._frames[i];\n            var rect = data.frame;\n            if (rect) {\n                var frame = null;\n                var trim = null;\n                var sourceSize = data.trimmed !== false && data.sourceSize\n                    ? data.sourceSize : data.frame;\n                var orig = new Rectangle(0, 0, Math.floor(sourceSize.w) / this.resolution, Math.floor(sourceSize.h) / this.resolution);\n                if (data.rotated) {\n                    frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.h) / this.resolution, Math.floor(rect.w) / this.resolution);\n                }\n                else {\n                    frame = new Rectangle(Math.floor(rect.x) / this.resolution, Math.floor(rect.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                }\n                //  Check to see if the sprite is trimmed\n                if (data.trimmed !== false && data.spriteSourceSize) {\n                    trim = new Rectangle(Math.floor(data.spriteSourceSize.x) / this.resolution, Math.floor(data.spriteSourceSize.y) / this.resolution, Math.floor(rect.w) / this.resolution, Math.floor(rect.h) / this.resolution);\n                }\n                this.textures[i] = new Texture(this.baseTexture, frame, orig, trim, data.rotated ? 2 : 0, data.anchor);\n                // lets also add the frame to pixi's global cache for 'from' and 'fromLoader' functions\n                Texture.addToCache(this.textures[i], i);\n            }\n            frameIndex++;\n        }\n    };\n    /**\n     * Parse animations config\n     *\n     * @private\n     */\n    Spritesheet.prototype._processAnimations = function () {\n        var animations = this.data.animations || {};\n        for (var animName in animations) {\n            this.animations[animName] = [];\n            for (var i = 0; i < animations[animName].length; i++) {\n                var frameName = animations[animName][i];\n                this.animations[animName].push(this.textures[frameName]);\n            }\n        }\n    };\n    /**\n     * The parse has completed.\n     *\n     * @private\n     */\n    Spritesheet.prototype._parseComplete = function () {\n        var callback = this._callback;\n        this._callback = null;\n        this._batchIndex = 0;\n        callback.call(this, this.textures);\n    };\n    /**\n     * Begin the next batch of textures.\n     *\n     * @private\n     */\n    Spritesheet.prototype._nextBatch = function () {\n        var _this = this;\n        this._processFrames(this._batchIndex * Spritesheet.BATCH_SIZE);\n        this._batchIndex++;\n        setTimeout(function () {\n            if (_this._batchIndex * Spritesheet.BATCH_SIZE < _this._frameKeys.length) {\n                _this._nextBatch();\n            }\n            else {\n                _this._processAnimations();\n                _this._parseComplete();\n            }\n        }, 0);\n    };\n    /**\n     * Destroy Spritesheet and don't use after this.\n     *\n     * @param {boolean} [destroyBase=false] - Whether to destroy the base texture as well\n     */\n    Spritesheet.prototype.destroy = function (destroyBase) {\n        var _a;\n        if (destroyBase === void 0) { destroyBase = false; }\n        for (var i in this.textures) {\n            this.textures[i].destroy();\n        }\n        this._frames = null;\n        this._frameKeys = null;\n        this.data = null;\n        this.textures = null;\n        if (destroyBase) {\n            (_a = this._texture) === null || _a === void 0 ? void 0 : _a.destroy();\n            this.baseTexture.destroy();\n        }\n        this._texture = null;\n        this.baseTexture = null;\n    };\n    /**\n     * The maximum number of Textures to build per process.\n     *\n     * @type {number}\n     * @default 1000\n     */\n    Spritesheet.BATCH_SIZE = 1000;\n    return Spritesheet;\n}());\n\n/**\n * {@link PIXI.Loader Loader} middleware for loading texture atlases that have been created with\n * TexturePacker or similar JSON-based spritesheet.\n *\n * This middleware automatically generates Texture resources.\n *\n * @class\n * @memberof PIXI\n * @implements PIXI.ILoaderPlugin\n */\nvar SpritesheetLoader = /** @class */ (function () {\n    function SpritesheetLoader() {\n    }\n    /**\n     * Called after a resource is loaded.\n     * @see PIXI.Loader.loaderMiddleware\n     * @param {PIXI.LoaderResource} resource\n     * @param {function} next\n     */\n    SpritesheetLoader.use = function (resource, next) {\n        // because this is middleware, it execute in loader context. `this` = loader\n        var loader = this;\n        var imageResourceName = resource.name + \"_image\";\n        // skip if no data, its not json, it isn't spritesheet data, or the image resource already exists\n        if (!resource.data\n            || resource.type !== LoaderResource.TYPE.JSON\n            || !resource.data.frames\n            || loader.resources[imageResourceName]) {\n            next();\n            return;\n        }\n        var loadOptions = {\n            crossOrigin: resource.crossOrigin,\n            metadata: resource.metadata.imageMetadata,\n            parentResource: resource,\n        };\n        var resourcePath = SpritesheetLoader.getResourcePath(resource, loader.baseUrl);\n        // load the image for this sheet\n        loader.add(imageResourceName, resourcePath, loadOptions, function onImageLoad(res) {\n            if (res.error) {\n                next(res.error);\n                return;\n            }\n            var spritesheet = new Spritesheet(res.texture, resource.data, resource.url);\n            spritesheet.parse(function () {\n                resource.spritesheet = spritesheet;\n                resource.textures = spritesheet.textures;\n                next();\n            });\n        });\n    };\n    /**\n     * Get the spritesheets root path\n     * @param {PIXI.LoaderResource} resource - Resource to check path\n     * @param {string} baseUrl - Base root url\n     */\n    SpritesheetLoader.getResourcePath = function (resource, baseUrl) {\n        // Prepend url path unless the resource image is a data url\n        if (resource.isDataUrl) {\n            return resource.data.meta.image;\n        }\n        return url.resolve(resource.url.replace(baseUrl, ''), resource.data.meta.image);\n    };\n    return SpritesheetLoader;\n}());\n\nexport { Spritesheet, SpritesheetLoader };\n//# sourceMappingURL=spritesheet.es.js.map\n"],"names":["Spritesheet","texture","data","resolutionFilename","this","_texture","baseTexture","textures","animations","resource","resolution","_updateResolution","url","_frames","frames","_frameKeys","Object","keys","_batchIndex","_callback","prototype","scale","meta","getResolutionOfUrl","undefined","parseFloat","setResolution","parse","callback","length","BATCH_SIZE","_processFrames","_processAnimations","_parseComplete","_nextBatch","initialFrameIndex","frameIndex","maxFrames","i","rect","frame","trim","sourceSize","trimmed","orig","Math","floor","w","h","rotated","x","y","spriteSourceSize","anchor","animName","frameName","push","call","_this","setTimeout","destroy","destroyBase","_a","SpritesheetLoader","use","next","loader","imageResourceName","name","type","resources","loadOptions","crossOrigin","metadata","imageMetadata","parentResource","resourcePath","getResourcePath","baseUrl","add","res","error","spritesheet","isDataUrl","image","replace"],"sourceRoot":""}