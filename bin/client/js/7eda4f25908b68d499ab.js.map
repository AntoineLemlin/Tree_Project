{"version":3,"file":"js/7eda4f25908b68d499ab.js","mappings":"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","sources":["webpack:///../../node_modules/@pixi/sprite-animated/lib/sprite-animated.es.js"],"sourcesContent":["/*!\n * @pixi/sprite-animated - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/sprite-animated is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { Texture } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\nimport { Ticker, UPDATE_PRIORITY } from '@pixi/ticker';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * let alienImages = [\"image_sequence_01.png\",\"image_sequence_02.png\",\"image_sequence_03.png\",\"image_sequence_04.png\"];\n * let textureArray = [];\n *\n * for (let i=0; i < 4; i++)\n * {\n *      let texture = PIXI.Texture.from(alienImages[i]);\n *      textureArray.push(texture);\n * };\n *\n * let animatedSprite = new PIXI.AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link PIXI.Spritesheet}\n * containing the animation definitions:\n *\n * ```js\n * PIXI.Loader.shared.add(\"assets/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"assets/spritesheet.json\"].spritesheet;\n *   animatedSprite = new PIXI.AnimatedSprite(sheet.animations[\"image_sequence\"]);\n *   ...\n * }\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n */\nvar AnimatedSprite = /** @class */ (function (_super) {\n    __extends(AnimatedSprite, _super);\n    /**\n     * @param {PIXI.Texture[]|PIXI.AnimatedSprite.FrameObject[]} textures - An array of {@link PIXI.Texture} or frame\n     *  objects that make up the animation.\n     * @param {boolean} [autoUpdate=true] - Whether to use PIXI.Ticker.shared to auto update animation time.\n     */\n    function AnimatedSprite(textures, autoUpdate) {\n        if (autoUpdate === void 0) { autoUpdate = true; }\n        var _this = _super.call(this, textures[0] instanceof Texture ? textures[0] : textures[0].texture) || this;\n        /**\n         * @type {PIXI.Texture[]}\n         * @private\n         */\n        _this._textures = null;\n        /**\n         * @type {number[]}\n         * @private\n         */\n        _this._durations = null;\n        /**\n         * `true` uses PIXI.Ticker.shared to auto update animation time.\n         *\n         * @type {boolean}\n         * @default true\n         * @private\n         */\n        _this._autoUpdate = autoUpdate;\n        /**\n         * `true` if the instance is currently connected to PIXI.Ticker.shared to auto update animation time.\n         *\n         * @type {boolean}\n         * @default false\n         * @private\n         */\n        _this._isConnectedToTicker = false;\n        /**\n         * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n         *\n         * @member {number}\n         * @default 1\n         */\n        _this.animationSpeed = 1;\n        /**\n         * Whether or not the animate sprite repeats after playing.\n         *\n         * @member {boolean}\n         * @default true\n         */\n        _this.loop = true;\n        /**\n         * Update anchor to [Texture's defaultAnchor]{@link PIXI.Texture#defaultAnchor} when frame changes.\n         *\n         * Useful with [sprite sheet animations]{@link PIXI.Spritesheet#animations} created with tools.\n         * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n         * of the frame (e.g. left foot).\n         *\n         * Note: Enabling this will override any previously set `anchor` on each frame change.\n         *\n         * @member {boolean}\n         * @default false\n         */\n        _this.updateAnchor = false;\n        /**\n         * User-assigned function to call when an AnimatedSprite finishes playing.\n         *\n         * @example\n         * animation.onComplete = function () {\n         *   // finished!\n         * };\n         * @member {Function}\n         */\n        _this.onComplete = null;\n        /**\n         * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n         *\n         * @example\n         * animation.onFrameChange = function () {\n         *   // updated!\n         * };\n         * @member {Function}\n         */\n        _this.onFrameChange = null;\n        /**\n         * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n         * loops around to start again.\n         *\n         * @example\n         * animation.onLoop = function () {\n         *   // looped!\n         * };\n         * @member {Function}\n         */\n        _this.onLoop = null;\n        /**\n         * Elapsed time since animation has been started, used internally to display current texture.\n         *\n         * @member {number}\n         * @private\n         */\n        _this._currentTime = 0;\n        _this._playing = false;\n        /**\n         * The texture index that was displayed last time\n         *\n         * @member {number}\n         * @private\n         */\n        _this._previousFrame = null;\n        _this.textures = textures;\n        return _this;\n    }\n    /**\n     * Stops the AnimatedSprite.\n     *\n     */\n    AnimatedSprite.prototype.stop = function () {\n        if (!this._playing) {\n            return;\n        }\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker) {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    };\n    /**\n     * Plays the AnimatedSprite.\n     *\n     */\n    AnimatedSprite.prototype.play = function () {\n        if (this._playing) {\n            return;\n        }\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker) {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    };\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     *\n     * @param {number} frameNumber - Frame index to stop at.\n     */\n    AnimatedSprite.prototype.gotoAndStop = function (frameNumber) {\n        this.stop();\n        var previousFrame = this.currentFrame;\n        this._currentTime = frameNumber;\n        if (previousFrame !== this.currentFrame) {\n            this.updateTexture();\n        }\n    };\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     *\n     * @param {number} frameNumber - Frame index to start at.\n     */\n    AnimatedSprite.prototype.gotoAndPlay = function (frameNumber) {\n        var previousFrame = this.currentFrame;\n        this._currentTime = frameNumber;\n        if (previousFrame !== this.currentFrame) {\n            this.updateTexture();\n        }\n        this.play();\n    };\n    /**\n     * Updates the object transform for rendering.\n     *\n     * @param {number} deltaTime - Time since last tick.\n     */\n    AnimatedSprite.prototype.update = function (deltaTime) {\n        if (!this._playing) {\n            return;\n        }\n        var elapsed = this.animationSpeed * deltaTime;\n        var previousFrame = this.currentFrame;\n        if (this._durations !== null) {\n            var lag = this._currentTime % 1 * this._durations[this.currentFrame];\n            lag += elapsed / 60 * 1000;\n            while (lag < 0) {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n            var sign = Math.sign(this.animationSpeed * deltaTime);\n            this._currentTime = Math.floor(this._currentTime);\n            while (lag >= this._durations[this.currentFrame]) {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else {\n            this._currentTime += elapsed;\n        }\n        if (this._currentTime < 0 && !this.loop) {\n            this.gotoAndStop(0);\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop) {\n            this.gotoAndStop(this._textures.length - 1);\n            if (this.onComplete) {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame) {\n            if (this.loop && this.onLoop) {\n                if (this.animationSpeed > 0 && this.currentFrame < previousFrame) {\n                    this.onLoop();\n                }\n                else if (this.animationSpeed < 0 && this.currentFrame > previousFrame) {\n                    this.onLoop();\n                }\n            }\n            this.updateTexture();\n        }\n    };\n    /**\n     * Updates the displayed texture to match the current frame index.\n     *\n     * @private\n     */\n    AnimatedSprite.prototype.updateTexture = function () {\n        var currentFrame = this.currentFrame;\n        if (this._previousFrame === currentFrame) {\n            return;\n        }\n        this._previousFrame = currentFrame;\n        this._texture = this._textures[currentFrame];\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n        this.uvs = this._texture._uvs.uvsFloat32;\n        if (this.updateAnchor) {\n            this._anchor.copyFrom(this._texture.defaultAnchor);\n        }\n        if (this.onFrameChange) {\n            this.onFrameChange(this.currentFrame);\n        }\n    };\n    /**\n     * Stops the AnimatedSprite and destroys it.\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value.\n     * @param {boolean} [options.children=false] - If set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well.\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well.\n     */\n    AnimatedSprite.prototype.destroy = function (options) {\n        this.stop();\n        _super.prototype.destroy.call(this, options);\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    };\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     *\n     * @static\n     * @param {string[]} frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @return {PIXI.AnimatedSprite} The new animated sprite with the specified frames.\n     */\n    AnimatedSprite.fromFrames = function (frames) {\n        var textures = [];\n        for (var i = 0; i < frames.length; ++i) {\n            textures.push(Texture.from(frames[i]));\n        }\n        return new AnimatedSprite(textures);\n    };\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     *\n     * @static\n     * @param {string[]} images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @return {PIXI.AnimatedSprite} The new animate sprite with the specified images as frames.\n     */\n    AnimatedSprite.fromImages = function (images) {\n        var textures = [];\n        for (var i = 0; i < images.length; ++i) {\n            textures.push(Texture.from(images[i]));\n        }\n        return new AnimatedSprite(textures);\n    };\n    Object.defineProperty(AnimatedSprite.prototype, \"totalFrames\", {\n        /**\n         * The total number of frames in the AnimatedSprite. This is the same as number of textures\n         * assigned to the AnimatedSprite.\n         *\n         * @readonly\n         * @member {number}\n         * @default 0\n         */\n        get: function () {\n            return this._textures.length;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedSprite.prototype, \"textures\", {\n        /**\n         * The array of textures used for this AnimatedSprite.\n         *\n         * @member {PIXI.Texture[]|PIXI.AnimatedSprite.FrameObject[]}\n         */\n        get: function () {\n            return this._textures;\n        },\n        set: function (value) {\n            if (value[0] instanceof Texture) {\n                this._textures = value;\n                this._durations = null;\n            }\n            else {\n                this._textures = [];\n                this._durations = [];\n                for (var i = 0; i < value.length; i++) {\n                    this._textures.push(value[i].texture);\n                    this._durations.push(value[i].time);\n                }\n            }\n            this._previousFrame = null;\n            this.gotoAndStop(0);\n            this.updateTexture();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedSprite.prototype, \"currentFrame\", {\n        /**\n        * The AnimatedSprites current frame index.\n        *\n        * @member {number}\n        * @readonly\n        */\n        get: function () {\n            var currentFrame = Math.floor(this._currentTime) % this._textures.length;\n            if (currentFrame < 0) {\n                currentFrame += this._textures.length;\n            }\n            return currentFrame;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedSprite.prototype, \"playing\", {\n        /**\n         * Indicates if the AnimatedSprite is currently playing.\n         *\n         * @member {boolean}\n         * @readonly\n         */\n        get: function () {\n            return this._playing;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(AnimatedSprite.prototype, \"autoUpdate\", {\n        /**\n         * Whether to use PIXI.Ticker.shared to auto update animation time\n         *\n         * @member {boolean}\n         */\n        get: function () {\n            return this._autoUpdate;\n        },\n        set: function (value) {\n            if (value !== this._autoUpdate) {\n                this._autoUpdate = value;\n                if (!this._autoUpdate && this._isConnectedToTicker) {\n                    Ticker.shared.remove(this.update, this);\n                    this._isConnectedToTicker = false;\n                }\n                else if (this._autoUpdate && !this._isConnectedToTicker && this._playing) {\n                    Ticker.shared.add(this.update, this);\n                    this._isConnectedToTicker = true;\n                }\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return AnimatedSprite;\n}(Sprite));\n/**\n * @memberof PIXI.AnimatedSprite\n * @typedef {object} FrameObject\n * @type {object}\n * @property {PIXI.Texture} texture - The {@link PIXI.Texture} of the frame\n * @property {number} time - the duration of the frame in ms\n */\n\nexport { AnimatedSprite };\n//# sourceMappingURL=sprite-animated.es.js.map\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","AnimatedSprite","_super","textures","autoUpdate","_this","call","this","texture","_textures","_durations","_autoUpdate","_isConnectedToTicker","animationSpeed","loop","updateAnchor","onComplete","onFrameChange","onLoop","_currentTime","_playing","_previousFrame","__","constructor","prototype","create","__extends","stop","update","play","gotoAndStop","frameNumber","previousFrame","currentFrame","updateTexture","gotoAndPlay","deltaTime","elapsed","lag","sign","Math","floor","length","_texture","_textureID","_textureTrimmedID","_cachedTint","uvs","_uvs","uvsFloat32","_anchor","copyFrom","defaultAnchor","destroy","options","fromFrames","frames","i","push","fromImages","images","defineProperty","get","enumerable","configurable","set","value","time"],"sourceRoot":""}