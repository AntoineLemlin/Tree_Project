{"version":3,"file":"js/cc31d85f30cff433ae73.js","mappings":"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","sources":["webpack:///../../node_modules/@pixi/extract/lib/extract.es.js"],"sourcesContent":["/*!\n * @pixi/extract - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/extract is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { CanvasRenderTarget } from '@pixi/utils';\nimport { Rectangle } from '@pixi/math';\nimport { RenderTexture } from '@pixi/core';\n\nvar TEMP_RECT = new Rectangle();\nvar BYTES_PER_PIXEL = 4;\n/**\n * This class provides renderer-specific plugins for exporting content from a renderer.\n * For instance, these plugins can be used for saving an Image, Canvas element or for exporting the raw image data (pixels).\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.plugins` property.\n * See {@link PIXI.CanvasRenderer#plugins} or {@link PIXI.Renderer#plugins}.\n * @example\n * // Create a new app (will auto-add extract plugin to renderer)\n * const app = new PIXI.Application();\n *\n * // Draw a red circle\n * const graphics = new PIXI.Graphics()\n *     .beginFill(0xFF0000)\n *     .drawCircle(0, 0, 50);\n *\n * // Render the graphics as an HTMLImageElement\n * const image = app.renderer.plugins.extract.image(graphics);\n * document.body.appendChild(image);\n * @class\n * @memberof PIXI\n */\nvar Extract = /** @class */ (function () {\n    /**\n     * @param {PIXI.Renderer} renderer - A reference to the current renderer\n     */\n    function Extract(renderer) {\n        this.renderer = renderer;\n        /**\n         * Collection of methods for extracting data (image, pixels, etc.) from a display object or render texture\n         *\n         * @member {PIXI.Extract} extract\n         * @memberof PIXI.Renderer#\n         * @see PIXI.Extract\n         */\n        renderer.extract = this;\n    }\n    /**\n     * Will return a HTML Image of the target\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param {string} [format] - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @return {HTMLImageElement} HTML Image of the target\n     */\n    Extract.prototype.image = function (target, format, quality) {\n        var image = new Image();\n        image.src = this.base64(target, format, quality);\n        return image;\n    };\n    /**\n     * Will return a a base64 encoded string of this target. It works by calling\n     *  `Extract.getCanvas` and then running toDataURL on that.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @param {string} [format] - Image format, e.g. \"image/jpeg\" or \"image/webp\".\n     * @param {number} [quality] - JPEG or Webp compression from 0 to 1. Default is 0.92.\n     * @return {string} A base64 encoded string of the texture.\n     */\n    Extract.prototype.base64 = function (target, format, quality) {\n        return this.canvas(target).toDataURL(format, quality);\n    };\n    /**\n     * Creates a Canvas element, renders this target to it and then returns it.\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n     */\n    Extract.prototype.canvas = function (target) {\n        var renderer = this.renderer;\n        var resolution;\n        var frame;\n        var flipY = false;\n        var renderTexture;\n        var generated = false;\n        if (target) {\n            if (target instanceof RenderTexture) {\n                renderTexture = target;\n            }\n            else {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n        if (renderTexture) {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = renderTexture.frame;\n            flipY = false;\n            renderer.renderTexture.bind(renderTexture);\n        }\n        else {\n            resolution = this.renderer.resolution;\n            flipY = true;\n            frame = TEMP_RECT;\n            frame.width = this.renderer.width;\n            frame.height = this.renderer.height;\n            renderer.renderTexture.bind(null);\n        }\n        var width = Math.floor((frame.width * resolution) + 1e-4);\n        var height = Math.floor((frame.height * resolution) + 1e-4);\n        var canvasBuffer = new CanvasRenderTarget(width, height, 1);\n        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n        // read pixels to the array\n        var gl = renderer.gl;\n        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n        // add the pixels to the canvas\n        var canvasData = canvasBuffer.context.getImageData(0, 0, width, height);\n        Extract.arrayPostDivide(webglPixels, canvasData.data);\n        canvasBuffer.context.putImageData(canvasData, 0, 0);\n        // pulling pixels\n        if (flipY) {\n            var target_1 = new CanvasRenderTarget(canvasBuffer.width, canvasBuffer.height, 1);\n            target_1.context.scale(1, -1);\n            // we can't render to itself because we should be empty before render.\n            target_1.context.drawImage(canvasBuffer.canvas, 0, -height);\n            canvasBuffer.destroy();\n            canvasBuffer = target_1;\n        }\n        if (generated) {\n            renderTexture.destroy(true);\n        }\n        // send the canvas back..\n        return canvasBuffer.canvas;\n    };\n    /**\n     * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA\n     * order, with integer values between 0 and 255 (included).\n     *\n     * @param {PIXI.DisplayObject|PIXI.RenderTexture} target - A displayObject or renderTexture\n     *  to convert. If left empty will use the main renderer\n     * @return {Uint8Array} One-dimensional array containing the pixel data of the entire texture\n     */\n    Extract.prototype.pixels = function (target) {\n        var renderer = this.renderer;\n        var resolution;\n        var frame;\n        var renderTexture;\n        var generated = false;\n        if (target) {\n            if (target instanceof RenderTexture) {\n                renderTexture = target;\n            }\n            else {\n                renderTexture = this.renderer.generateTexture(target);\n                generated = true;\n            }\n        }\n        if (renderTexture) {\n            resolution = renderTexture.baseTexture.resolution;\n            frame = renderTexture.frame;\n            // bind the buffer\n            renderer.renderTexture.bind(renderTexture);\n        }\n        else {\n            resolution = renderer.resolution;\n            frame = TEMP_RECT;\n            frame.width = renderer.width;\n            frame.height = renderer.height;\n            renderer.renderTexture.bind(null);\n        }\n        var width = frame.width * resolution;\n        var height = frame.height * resolution;\n        var webglPixels = new Uint8Array(BYTES_PER_PIXEL * width * height);\n        // read pixels to the array\n        var gl = renderer.gl;\n        gl.readPixels(frame.x * resolution, frame.y * resolution, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webglPixels);\n        if (generated) {\n            renderTexture.destroy(true);\n        }\n        Extract.arrayPostDivide(webglPixels, webglPixels);\n        return webglPixels;\n    };\n    /**\n     * Destroys the extract\n     *\n     */\n    Extract.prototype.destroy = function () {\n        this.renderer.extract = null;\n        this.renderer = null;\n    };\n    /**\n     * Takes premultiplied pixel data and produces regular pixel data\n     *\n     * @private\n     * @param pixels {number[] | Uint8Array | Uint8ClampedArray} array of pixel data\n     * @param out {number[] | Uint8Array | Uint8ClampedArray} output array\n     */\n    Extract.arrayPostDivide = function (pixels, out) {\n        for (var i = 0; i < pixels.length; i += 4) {\n            var alpha = out[i + 3] = pixels[i + 3];\n            if (alpha !== 0) {\n                out[i] = Math.round(Math.min(pixels[i] * 255.0 / alpha, 255.0));\n                out[i + 1] = Math.round(Math.min(pixels[i + 1] * 255.0 / alpha, 255.0));\n                out[i + 2] = Math.round(Math.min(pixels[i + 2] * 255.0 / alpha, 255.0));\n            }\n            else {\n                out[i] = pixels[i];\n                out[i + 1] = pixels[i + 1];\n                out[i + 2] = pixels[i + 2];\n            }\n        }\n    };\n    return Extract;\n}());\n\nexport { Extract };\n//# sourceMappingURL=extract.es.js.map\n"],"names":["TEMP_RECT","Extract","renderer","this","extract","prototype","image","target","format","quality","Image","src","base64","canvas","toDataURL","resolution","frame","renderTexture","flipY","generated","generateTexture","baseTexture","bind","width","height","Math","floor","canvasBuffer","CanvasRenderTarget","webglPixels","Uint8Array","gl","readPixels","x","y","RGBA","UNSIGNED_BYTE","canvasData","context","getImageData","arrayPostDivide","data","putImageData","target_1","scale","drawImage","destroy","pixels","out","i","length","alpha","round","min"],"sourceRoot":""}