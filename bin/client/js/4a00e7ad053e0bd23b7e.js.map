{"version":3,"file":"js/4a00e7ad053e0bd23b7e.js","mappings":"qKA8BIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAASA,EAAEM,eAAeD,KAAMN,EAAEM,GAAKL,EAAEK,KACtEP,EAAcC,EAAGC,IASxBO,EAAY,IAAI,KAChBC,EAAU,IAAIC,YAAY,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,IA2B1CC,EAAwB,SAAUC,GAKlC,SAASD,EAAOE,GACZ,IAAIC,EAAQF,EAAOG,KAAKC,OAASA,KA8HjC,OA3GAF,EAAMG,QAAU,IAAI,KAAgBH,EAAMI,gBAAiBJ,EAAQD,EAAUA,EAAQM,cAAcC,EAAI,EAAKP,EAAUA,EAAQM,cAAcE,EAAI,GAOhJP,EAAMQ,SAAW,KAOjBR,EAAMS,OAAS,EAOfT,EAAMU,QAAU,EAQhBV,EAAMW,MAAQ,KAQdX,EAAMY,SAAW,KACjBZ,EAAMa,KAAO,SAQbb,EAAMc,UAAY,YASlBd,EAAMe,YAAc,SAQpBf,EAAMgB,IAAM,KAEZhB,EAAMD,QAAUA,GAAW,WAO3BC,EAAMiB,WAAa,IAAIC,aAAa,GAOpClB,EAAMmB,kBAAoB,KAC1BnB,EAAMoB,cAAgB,EACtBpB,EAAMqB,YAAc,EACpBrB,EAAMsB,qBAAuB,EAC7BtB,EAAMuB,mBAAqB,EAG3BvB,EAAML,QAAUA,EAQhBK,EAAMwB,WAAa,QAKnBxB,EAAMyB,UAAW,EAOjBzB,EAAM0B,aAAe,iBACd1B,EA6XX,OAniBJ,SAAmBd,EAAGC,GAElB,SAASwC,IAAOzB,KAAK0B,YAAc1C,EADnCD,EAAcC,EAAGC,GAEjBD,EAAE2C,UAAkB,OAAN1C,EAAaC,OAAO0C,OAAO3C,IAAMwC,EAAGE,UAAY1C,EAAE0C,UAAW,IAAIF,GAgC/EI,CAAUlC,EAAQC,GA0IlBD,EAAOgC,UAAUG,iBAAmB,WAChC9B,KAAKmB,YAAc,EACnBnB,KAAKqB,mBAAqB,EAC1BrB,KAAKa,YAAc,SAEfb,KAAKO,SACLP,KAAK+B,MAAM3B,GAAI,IAAA4B,MAAKhC,KAAK+B,MAAM3B,GAAKJ,KAAKO,OAASP,KAAKM,SAAS2B,KAAKC,OAErElC,KAAKQ,UACLR,KAAK+B,MAAM1B,GAAI,IAAA2B,MAAKhC,KAAK+B,MAAM1B,GAAKL,KAAKQ,QAAUR,KAAKM,SAAS2B,KAAKE,SAQ9ExC,EAAOgC,UAAUzB,gBAAkB,WAC/BF,KAAKkB,cAAgB,EACrBlB,KAAKoB,qBAAuB,GAKhCzB,EAAOgC,UAAUS,kBAAoB,WACjC,IAAIvC,EAAUG,KAAKM,SACnB,GAAIN,KAAKkB,eAAiBlB,KAAKqC,UAAUC,UAAYtC,KAAKmB,aAAetB,EAAQ0C,UAAjF,CAIIvC,KAAKmB,aAAetB,EAAQ0C,YAC5BvC,KAAKc,IAAMd,KAAKM,SAASkC,KAAKC,YAElCzC,KAAKkB,aAAelB,KAAKqC,UAAUC,SACnCtC,KAAKmB,WAAatB,EAAQ0C,UAE1B,IAAIG,EAAK1C,KAAKqC,UAAUM,eACpBC,EAAIF,EAAGE,EACP3D,EAAIyD,EAAGzD,EACP4D,EAAIH,EAAGG,EACP7D,EAAI0D,EAAG1D,EACP8D,EAAKJ,EAAGI,GACRC,EAAKL,EAAGK,GACRhC,EAAaf,KAAKe,WAClBiC,EAAOnD,EAAQmD,KACff,EAAOpC,EAAQoC,KACfgB,EAASjD,KAAKC,QACdiD,EAAK,EACLC,EAAK,EACLC,EAAK,EACLC,EAAK,EA2BT,GA1BIL,GAIAE,GADAC,EAAKH,EAAK5C,EAAK6C,EAAOK,GAAKrB,EAAKC,OACtBc,EAAKd,MAEfkB,GADAC,EAAKL,EAAK3C,EAAK4C,EAAOM,GAAKtB,EAAKE,QACtBa,EAAKb,SAIfe,GADAC,GAAMF,EAAOK,GAAKrB,EAAKC,OACbD,EAAKC,MAEfkB,GADAC,GAAMJ,EAAOM,GAAKtB,EAAKE,QACbF,EAAKE,QAGnBpB,EAAW,GAAM6B,EAAIO,EAAON,EAAIQ,EAAMP,EACtC/B,EAAW,GAAM/B,EAAIqE,EAAOpE,EAAIkE,EAAMJ,EAEtChC,EAAW,GAAM6B,EAAIM,EAAOL,EAAIQ,EAAMP,EACtC/B,EAAW,GAAM/B,EAAIqE,EAAOpE,EAAIiE,EAAMH,EAEtChC,EAAW,GAAM6B,EAAIM,EAAOL,EAAIO,EAAMN,EACtC/B,EAAW,GAAM/B,EAAIoE,EAAOnE,EAAIiE,EAAMH,EAEtChC,EAAW,GAAM6B,EAAIO,EAAON,EAAIO,EAAMN,EACtC/B,EAAW,GAAM/B,EAAIoE,EAAOnE,EAAIkE,EAAMJ,EAClC/C,KAAKwB,aAEL,IADA,IAAIgC,EAAa,eACRC,EAAI,EAAGA,EAAI1C,EAAW2C,SAAUD,EACrC1C,EAAW0C,GAAKE,KAAKC,OAAO7C,EAAW0C,GAAKD,EAAa,GAAKA,KAQ1E7D,EAAOgC,UAAUkC,yBAA2B,WACxC,GAAK7D,KAAKiB,mBAGL,GAAIjB,KAAKoB,sBAAwBpB,KAAKqC,UAAUC,UAAYtC,KAAKqB,oBAAsBrB,KAAKM,SAASiC,UACtG,YAHAvC,KAAKiB,kBAAoB,IAAID,aAAa,GAK9ChB,KAAKoB,oBAAsBpB,KAAKqC,UAAUC,SAC1CtC,KAAKqB,kBAAoBrB,KAAKM,SAASiC,UAEvC,IAAI1C,EAAUG,KAAKM,SACfS,EAAaf,KAAKiB,kBAClBgB,EAAOpC,EAAQoC,KACfgB,EAASjD,KAAKC,QAEdyC,EAAK1C,KAAKqC,UAAUM,eACpBC,EAAIF,EAAGE,EACP3D,EAAIyD,EAAGzD,EACP4D,EAAIH,EAAGG,EACP7D,EAAI0D,EAAG1D,EACP8D,EAAKJ,EAAGI,GACRC,EAAKL,EAAGK,GACRI,GAAMF,EAAOK,GAAKrB,EAAKC,MACvBgB,EAAKC,EAAKlB,EAAKC,MACfmB,GAAMJ,EAAOM,GAAKtB,EAAKE,OACvBiB,EAAKC,EAAKpB,EAAKE,OAEnBpB,EAAW,GAAM6B,EAAIO,EAAON,EAAIQ,EAAMP,EACtC/B,EAAW,GAAM/B,EAAIqE,EAAOpE,EAAIkE,EAAMJ,EAEtChC,EAAW,GAAM6B,EAAIM,EAAOL,EAAIQ,EAAMP,EACtC/B,EAAW,GAAM/B,EAAIqE,EAAOpE,EAAIiE,EAAMH,EAEtChC,EAAW,GAAM6B,EAAIM,EAAOL,EAAIO,EAAMN,EACtC/B,EAAW,GAAM/B,EAAIoE,EAAOnE,EAAIiE,EAAMH,EAEtChC,EAAW,GAAM6B,EAAIO,EAAON,EAAIO,EAAMN,EACtC/B,EAAW,GAAM/B,EAAIoE,EAAOnE,EAAIkE,EAAMJ,GAS1CpD,EAAOgC,UAAUmC,QAAU,SAAUC,GACjC/D,KAAKoC,oBACL2B,EAASC,MAAMC,kBAAkBF,EAASG,QAAQlE,KAAKsB,aACvDyC,EAASG,QAAQlE,KAAKsB,YAAY6C,OAAOnE,OAO7CL,EAAOgC,UAAUyC,iBAAmB,WAChC,IAAIpB,EAAOhD,KAAKM,SAAS0C,KACrBf,EAAOjC,KAAKM,SAAS2B,MAEpBe,GAASA,EAAKd,QAAUD,EAAKC,OAASc,EAAKb,SAAWF,EAAKE,QAE5DnC,KAAKoC,oBACLpC,KAAKqE,QAAQC,QAAQtE,KAAKe,cAI1Bf,KAAK6D,2BACL7D,KAAKqE,QAAQC,QAAQtE,KAAKiB,qBASlCtB,EAAOgC,UAAU4C,eAAiB,SAAUC,GAExC,OAA6B,IAAzBxE,KAAKyE,SAASf,QACd1D,KAAKqE,QAAQK,KAAO1E,KAAKM,SAAS2B,KAAKC,OAASlC,KAAKC,QAAQqD,GAC7DtD,KAAKqE,QAAQM,KAAO3E,KAAKM,SAAS2B,KAAKE,QAAUnC,KAAKC,QAAQsD,GAC9DvD,KAAKqE,QAAQO,KAAO5E,KAAKM,SAAS2B,KAAKC,OAAS,EAAIlC,KAAKC,QAAQqD,IACjEtD,KAAKqE,QAAQQ,KAAO7E,KAAKM,SAAS2B,KAAKE,QAAU,EAAInC,KAAKC,QAAQsD,IAC7DiB,IACIxE,KAAK8E,mBACN9E,KAAK8E,iBAAmB,IAAI,MAEhCN,EAAOxE,KAAK8E,kBAET9E,KAAKqE,QAAQU,aAAaP,IAE9B5E,EAAO+B,UAAU4C,eAAexE,KAAKC,KAAMwE,IAQtD7E,EAAOgC,UAAUqD,cAAgB,SAAUC,GACvCjF,KAAK2C,eAAeuC,aAAaD,EAAOzF,GACxC,IAAI0C,EAAQlC,KAAKM,SAAS2B,KAAKC,MAC3BC,EAASnC,KAAKM,SAAS2B,KAAKE,OAC5BgD,GAAMjD,EAAQlC,KAAKiD,OAAO7C,EAC1BgF,EAAK,EACT,OAAI5F,EAAUY,GAAK+E,GAAM3F,EAAUY,EAAI+E,EAAKjD,IACxCkD,GAAMjD,EAASnC,KAAKiD,OAAO5C,EACvBb,EAAUa,GAAK+E,GAAM5F,EAAUa,EAAI+E,EAAKjD,IAgBpDxC,EAAOgC,UAAU0D,QAAU,SAAUC,GAKjC,GAJA1F,EAAO+B,UAAU0D,QAAQtF,KAAKC,KAAMsF,GACpCtF,KAAKM,SAASiF,IAAI,SAAUvF,KAAK8B,iBAAkB9B,MACnDA,KAAKC,QAAU,KACyB,kBAAZqF,EAAwBA,EAAUA,GAAWA,EAAQzF,QAC7D,CAChB,IAAI2F,EAAwC,kBAAZF,EAAwBA,EAAUA,GAAWA,EAAQG,YACrFzF,KAAKM,SAAS+E,UAAUG,GAE5BxF,KAAKM,SAAW,MAYpBX,EAAO+F,KAAO,SAAUC,EAAQL,GAI5B,OAAO,IAAI3F,EAHIgG,aAAkB,KAC3BA,EACA,UAAaA,EAAQL,KAG/BpG,OAAO0G,eAAejG,EAAOgC,UAAW,cAAe,CACnDkE,IAAK,WACD,OAAO7F,KAAKwB,cAWhBsE,IAAK,SAAUC,GACP/F,KAAKwB,eAAiBuE,IACtB/F,KAAKkB,cAAgB,GAEzBlB,KAAKwB,aAAeuE,GAExBC,YAAY,EACZC,cAAc,IAElB/G,OAAO0G,eAAejG,EAAOgC,UAAW,QAAS,CAM7CkE,IAAK,WACD,OAAOlC,KAAKuC,IAAIlG,KAAK+B,MAAM3B,GAAKJ,KAAKM,SAAS2B,KAAKC,OAEvD4D,IAAK,SAAUC,GACX,IAAII,GAAI,IAAAnE,MAAKhC,KAAK+B,MAAM3B,IAAM,EAC9BJ,KAAK+B,MAAM3B,EAAI+F,EAAIJ,EAAQ/F,KAAKM,SAAS2B,KAAKC,MAC9ClC,KAAKO,OAASwF,GAElBC,YAAY,EACZC,cAAc,IAElB/G,OAAO0G,eAAejG,EAAOgC,UAAW,SAAU,CAM9CkE,IAAK,WACD,OAAOlC,KAAKuC,IAAIlG,KAAK+B,MAAM1B,GAAKL,KAAKM,SAAS2B,KAAKE,QAEvD2D,IAAK,SAAUC,GACX,IAAII,GAAI,IAAAnE,MAAKhC,KAAK+B,MAAM1B,IAAM,EAC9BL,KAAK+B,MAAM1B,EAAI8F,EAAIJ,EAAQ/F,KAAKM,SAAS2B,KAAKE,OAC9CnC,KAAKQ,QAAUuF,GAEnBC,YAAY,EACZC,cAAc,IAElB/G,OAAO0G,eAAejG,EAAOgC,UAAW,SAAU,CAmB9CkE,IAAK,WACD,OAAO7F,KAAKC,SAEhB6F,IAAK,SAAUC,GACX/F,KAAKC,QAAQmG,SAASL,IAE1BC,YAAY,EACZC,cAAc,IAElB/G,OAAO0G,eAAejG,EAAOgC,UAAW,OAAQ,CAQ5CkE,IAAK,WACD,OAAO7F,KAAKS,OAEhBqF,IAAK,SAAUC,GACX/F,KAAKS,MAAQsF,EACb/F,KAAKU,UAAYqF,GAAS,KAAe,MAARA,KAA4B,IAARA,IAAiB,KAE1EC,YAAY,EACZC,cAAc,IAElB/G,OAAO0G,eAAejG,EAAOgC,UAAW,UAAW,CAM/CkE,IAAK,WACD,OAAO7F,KAAKM,UAEhBwF,IAAK,SAAUC,GACP/F,KAAKM,WAAayF,IAGlB/F,KAAKM,UACLN,KAAKM,SAASiF,IAAI,SAAUvF,KAAK8B,iBAAkB9B,MAEvDA,KAAKM,SAAWyF,GAAS,WACzB/F,KAAKa,YAAc,SACnBb,KAAKmB,YAAc,EACnBnB,KAAKqB,mBAAqB,EACtB0E,IAEIA,EAAMN,YAAYY,MAClBrG,KAAK8B,mBAGLiE,EAAMO,KAAK,SAAUtG,KAAK8B,iBAAkB9B,SAIxDgG,YAAY,EACZC,cAAc,IAEXtG,EAjgBgB,CAkgBzB","sources":["webpack:///../../node_modules/@pixi/sprite/lib/sprite.es.js"],"sourcesContent":["/*!\n * @pixi/sprite - v5.3.11\n * Compiled Mon, 01 Nov 2021 16:10:12 UTC\n *\n * @pixi/sprite is licensed under the MIT License.\n * http://www.opensource.org/licenses/mit-license\n */\nimport { BLEND_MODES } from '@pixi/constants';\nimport { Texture } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Point, ObservablePoint, Rectangle } from '@pixi/math';\nimport { settings } from '@pixi/settings';\nimport { sign } from '@pixi/utils';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) { if (b.hasOwnProperty(p)) { d[p] = b[p]; } } };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar tempPoint = new Point();\nvar indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n*\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * let sprite = PIXI.Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link PIXI.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * PIXI.Loader.shared.add(\"assets/spritesheet.json\").load(setup);\n *\n * function setup() {\n *   let sheet = PIXI.Loader.shared.resources[\"assets/spritesheet.json\"].spritesheet;\n *   let sprite = new PIXI.Sprite(sheet.textures[\"image.png\"]);\n *   ...\n * }\n * ```\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nvar Sprite = /** @class */ (function (_super) {\n    __extends(Sprite, _super);\n    /**\n     * @param {PIXI.Texture} [texture] - The texture for this sprite.\n     */\n    function Sprite(texture) {\n        var _this = _super.call(this) || this;\n        /**\n         * The anchor point defines the normalized coordinates\n         * in the texture that map to the position of this\n         * sprite.\n         *\n         * By default, this is `(0,0)` (or `texture.defaultAnchor`\n         * if you have modified that), which means the position\n         * `(x,y)` of this `Sprite` will be the top-left corner.\n         *\n         * Note: Updating `texture.defaultAnchor` after\n         * constructing a `Sprite` does _not_ update its anchor.\n         *\n         * {@link https://docs.cocos2d-x.org/cocos2d-x/en/sprites/manipulation.html}\n         *\n         * @default `texture.defaultAnchor`\n         * @member {PIXI.ObservablePoint}\n         * @private\n         */\n        _this._anchor = new ObservablePoint(_this._onAnchorUpdate, _this, (texture ? texture.defaultAnchor.x : 0), (texture ? texture.defaultAnchor.y : 0));\n        /**\n         * The texture that the sprite is using\n         *\n         * @private\n         * @member {PIXI.Texture}\n         */\n        _this._texture = null;\n        /**\n         * The width of the sprite (this is initially set by the texture)\n         *\n         * @protected\n         * @member {number}\n         */\n        _this._width = 0;\n        /**\n         * The height of the sprite (this is initially set by the texture)\n         *\n         * @protected\n         * @member {number}\n         */\n        _this._height = 0;\n        /**\n         * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @private\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        _this._tint = null;\n        /**\n         * The tint applied to the sprite. This is a RGB value. A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @private\n         * @member {number}\n         * @default 16777215\n         */\n        _this._tintRGB = null;\n        _this.tint = 0xFFFFFF;\n        /**\n         * The blend mode to be applied to the sprite. Apply a value of `PIXI.BLEND_MODES.NORMAL` to reset the blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        _this.blendMode = BLEND_MODES.NORMAL;\n        /**\n         * Cached tint value so we can tell when the tint is changed.\n         * Value is used for 2d CanvasRenderer.\n         *\n         * @protected\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        _this._cachedTint = 0xFFFFFF;\n        /**\n         * this is used to store the uvs data of the sprite, assigned at the same time\n         * as the vertexData in calculateVertices()\n         *\n         * @private\n         * @member {Float32Array}\n         */\n        _this.uvs = null;\n        // call texture setter\n        _this.texture = texture || Texture.EMPTY;\n        /**\n         * this is used to store the vertex data of the sprite (basically a quad)\n         *\n         * @private\n         * @member {Float32Array}\n         */\n        _this.vertexData = new Float32Array(8);\n        /**\n         * This is used to calculate the bounds of the object IF it is a trimmed sprite\n         *\n         * @private\n         * @member {Float32Array}\n         */\n        _this.vertexTrimmedData = null;\n        _this._transformID = -1;\n        _this._textureID = -1;\n        _this._transformTrimmedID = -1;\n        _this._textureTrimmedID = -1;\n        // Batchable stuff..\n        // TODO could make this a mixin?\n        _this.indices = indices;\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_render' & '_renderCanvas' methods.\n         *\n         * @member {string}\n         * @default 'batch'\n         */\n        _this.pluginName = 'batch';\n        /**\n         * used to fast check if a sprite is.. a sprite!\n         * @member {boolean}\n         */\n        _this.isSprite = true;\n        /**\n         * Internal roundPixels field\n         *\n         * @member {boolean}\n         * @private\n         */\n        _this._roundPixels = settings.ROUND_PIXELS;\n        return _this;\n    }\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @protected\n     */\n    Sprite.prototype._onTextureUpdate = function () {\n        this._textureID = -1;\n        this._textureTrimmedID = -1;\n        this._cachedTint = 0xFFFFFF;\n        // so if _width is 0 then width was not set..\n        if (this._width) {\n            this.scale.x = sign(this.scale.x) * this._width / this._texture.orig.width;\n        }\n        if (this._height) {\n            this.scale.y = sign(this.scale.y) * this._height / this._texture.orig.height;\n        }\n    };\n    /**\n     * Called when the anchor position updates.\n     *\n     * @private\n     */\n    Sprite.prototype._onAnchorUpdate = function () {\n        this._transformID = -1;\n        this._transformTrimmedID = -1;\n    };\n    /**\n     * calculates worldTransform * vertices, store it in vertexData\n     */\n    Sprite.prototype.calculateVertices = function () {\n        var texture = this._texture;\n        if (this._transformID === this.transform._worldID && this._textureID === texture._updateID) {\n            return;\n        }\n        // update texture UV here, because base texture can be changed without calling `_onTextureUpdate`\n        if (this._textureID !== texture._updateID) {\n            this.uvs = this._texture._uvs.uvsFloat32;\n        }\n        this._transformID = this.transform._worldID;\n        this._textureID = texture._updateID;\n        // set the vertex data\n        var wt = this.transform.worldTransform;\n        var a = wt.a;\n        var b = wt.b;\n        var c = wt.c;\n        var d = wt.d;\n        var tx = wt.tx;\n        var ty = wt.ty;\n        var vertexData = this.vertexData;\n        var trim = texture.trim;\n        var orig = texture.orig;\n        var anchor = this._anchor;\n        var w0 = 0;\n        var w1 = 0;\n        var h0 = 0;\n        var h1 = 0;\n        if (trim) {\n            // if the sprite is trimmed and is not a tilingsprite then we need to add the extra\n            // space before transforming the sprite coords.\n            w1 = trim.x - (anchor._x * orig.width);\n            w0 = w1 + trim.width;\n            h1 = trim.y - (anchor._y * orig.height);\n            h0 = h1 + trim.height;\n        }\n        else {\n            w1 = -anchor._x * orig.width;\n            w0 = w1 + orig.width;\n            h1 = -anchor._y * orig.height;\n            h0 = h1 + orig.height;\n        }\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n        if (this._roundPixels) {\n            var resolution = settings.RESOLUTION;\n            for (var i = 0; i < vertexData.length; ++i) {\n                vertexData[i] = Math.round((vertexData[i] * resolution | 0) / resolution);\n            }\n        }\n    };\n    /**\n     * calculates worldTransform * vertices for a non texture with a trim. store it in vertexTrimmedData\n     * This is used to ensure that the true width and height of a trimmed texture is respected\n     */\n    Sprite.prototype.calculateTrimmedVertices = function () {\n        if (!this.vertexTrimmedData) {\n            this.vertexTrimmedData = new Float32Array(8);\n        }\n        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) {\n            return;\n        }\n        this._transformTrimmedID = this.transform._worldID;\n        this._textureTrimmedID = this._texture._updateID;\n        // lets do some special trim code!\n        var texture = this._texture;\n        var vertexData = this.vertexTrimmedData;\n        var orig = texture.orig;\n        var anchor = this._anchor;\n        // lets calculate the new untrimmed bounds..\n        var wt = this.transform.worldTransform;\n        var a = wt.a;\n        var b = wt.b;\n        var c = wt.c;\n        var d = wt.d;\n        var tx = wt.tx;\n        var ty = wt.ty;\n        var w1 = -anchor._x * orig.width;\n        var w0 = w1 + orig.width;\n        var h1 = -anchor._y * orig.height;\n        var h0 = h1 + orig.height;\n        // xy\n        vertexData[0] = (a * w1) + (c * h1) + tx;\n        vertexData[1] = (d * h1) + (b * w1) + ty;\n        // xy\n        vertexData[2] = (a * w0) + (c * h1) + tx;\n        vertexData[3] = (d * h1) + (b * w0) + ty;\n        // xy\n        vertexData[4] = (a * w0) + (c * h0) + tx;\n        vertexData[5] = (d * h0) + (b * w0) + ty;\n        // xy\n        vertexData[6] = (a * w1) + (c * h0) + tx;\n        vertexData[7] = (d * h0) + (b * w1) + ty;\n    };\n    /**\n    *\n    * Renders the object using the WebGL renderer\n    *\n    * @protected\n    * @param {PIXI.Renderer} renderer - The webgl renderer to use.\n    */\n    Sprite.prototype._render = function (renderer) {\n        this.calculateVertices();\n        renderer.batch.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    };\n    /**\n     * Updates the bounds of the sprite.\n     *\n     * @protected\n     */\n    Sprite.prototype._calculateBounds = function () {\n        var trim = this._texture.trim;\n        var orig = this._texture.orig;\n        // First lets check to see if the current texture has a trim..\n        if (!trim || (trim.width === orig.width && trim.height === orig.height)) {\n            // no trim! lets use the usual calculations..\n            this.calculateVertices();\n            this._bounds.addQuad(this.vertexData);\n        }\n        else {\n            // lets calculate a special trimmed bounds...\n            this.calculateTrimmedVertices();\n            this._bounds.addQuad(this.vertexTrimmedData);\n        }\n    };\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} [rect] - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    Sprite.prototype.getLocalBounds = function (rect) {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0) {\n            this._bounds.minX = this._texture.orig.width * -this._anchor._x;\n            this._bounds.minY = this._texture.orig.height * -this._anchor._y;\n            this._bounds.maxX = this._texture.orig.width * (1 - this._anchor._x);\n            this._bounds.maxY = this._texture.orig.height * (1 - this._anchor._y);\n            if (!rect) {\n                if (!this._localBoundsRect) {\n                    this._localBoundsRect = new Rectangle();\n                }\n                rect = this._localBoundsRect;\n            }\n            return this._bounds.getRectangle(rect);\n        }\n        return _super.prototype.getLocalBounds.call(this, rect);\n    };\n    /**\n     * Tests if a point is inside this sprite\n     *\n     * @param {PIXI.IPointData} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    Sprite.prototype.containsPoint = function (point) {\n        this.worldTransform.applyInverse(point, tempPoint);\n        var width = this._texture.orig.width;\n        var height = this._texture.orig.height;\n        var x1 = -width * this.anchor.x;\n        var y1 = 0;\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width) {\n            y1 = -height * this.anchor.y;\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    Sprite.prototype.destroy = function (options) {\n        _super.prototype.destroy.call(this, options);\n        this._texture.off('update', this._onTextureUpdate, this);\n        this._anchor = null;\n        var destroyTexture = typeof options === 'boolean' ? options : options && options.texture;\n        if (destroyTexture) {\n            var destroyBaseTexture = typeof options === 'boolean' ? options : options && options.baseTexture;\n            this._texture.destroy(!!destroyBaseTexture);\n        }\n        this._texture = null;\n    };\n    // some helper functions..\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {string|PIXI.Texture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {object} [options] - See {@link PIXI.BaseTexture}'s constructor for options.\n     * @return {PIXI.Sprite} The newly created sprite\n     */\n    Sprite.from = function (source, options) {\n        var texture = (source instanceof Texture)\n            ? source\n            : Texture.from(source, options);\n        return new Sprite(texture);\n    };\n    Object.defineProperty(Sprite.prototype, \"roundPixels\", {\n        get: function () {\n            return this._roundPixels;\n        },\n        /**\n         * If true PixiJS will Math.floor() x/y values when rendering, stopping pixel interpolation.\n         * Advantages can include sharper image quality (like text) and faster rendering on canvas.\n         * The main disadvantage is movement of objects may appear less smooth.\n         * To set the global default, change {@link PIXI.settings.ROUND_PIXELS}\n         *\n         * @member {boolean}\n         * @default false\n         */\n        set: function (value) {\n            if (this._roundPixels !== value) {\n                this._transformID = -1;\n            }\n            this._roundPixels = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"width\", {\n        /**\n         * The width of the sprite, setting this will actually modify the scale to achieve the value set\n         *\n         * @member {number}\n         */\n        get: function () {\n            return Math.abs(this.scale.x) * this._texture.orig.width;\n        },\n        set: function (value) {\n            var s = sign(this.scale.x) || 1;\n            this.scale.x = s * value / this._texture.orig.width;\n            this._width = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"height\", {\n        /**\n         * The height of the sprite, setting this will actually modify the scale to achieve the value set\n         *\n         * @member {number}\n         */\n        get: function () {\n            return Math.abs(this.scale.y) * this._texture.orig.height;\n        },\n        set: function (value) {\n            var s = sign(this.scale.y) || 1;\n            this.scale.y = s * value / this._texture.orig.height;\n            this._height = value;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"anchor\", {\n        /**\n         * The anchor sets the origin point of the sprite. The default value is taken from the {@link PIXI.Texture|Texture}\n         * and passed to the constructor.\n         *\n         * The default is `(0,0)`, this means the sprite's origin is the top left.\n         *\n         * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n         *\n         * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n         *\n         * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n         *\n         * @example\n         * const sprite = new PIXI.Sprite(texture);\n         * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n         *\n         * @member {PIXI.ObservablePoint}\n         */\n        get: function () {\n            return this._anchor;\n        },\n        set: function (value) {\n            this._anchor.copyFrom(value);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"tint\", {\n        /**\n         * The tint applied to the sprite. This is a hex value.\n         * A value of 0xFFFFFF will remove any tint effect.\n         *\n         * @member {number}\n         * @default 0xFFFFFF\n         */\n        get: function () {\n            return this._tint;\n        },\n        set: function (value) {\n            this._tint = value;\n            this._tintRGB = (value >> 16) + (value & 0xff00) + ((value & 0xff) << 16);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(Sprite.prototype, \"texture\", {\n        /**\n         * The texture that the sprite is using\n         *\n         * @member {PIXI.Texture}\n         */\n        get: function () {\n            return this._texture;\n        },\n        set: function (value) {\n            if (this._texture === value) {\n                return;\n            }\n            if (this._texture) {\n                this._texture.off('update', this._onTextureUpdate, this);\n            }\n            this._texture = value || Texture.EMPTY;\n            this._cachedTint = 0xFFFFFF;\n            this._textureID = -1;\n            this._textureTrimmedID = -1;\n            if (value) {\n                // wait for the texture to load\n                if (value.baseTexture.valid) {\n                    this._onTextureUpdate();\n                }\n                else {\n                    value.once('update', this._onTextureUpdate, this);\n                }\n            }\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return Sprite;\n}(Container));\n\nexport { Sprite };\n//# sourceMappingURL=sprite.es.js.map\n"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","tempPoint","indices","Uint16Array","Sprite","_super","texture","_this","call","this","_anchor","_onAnchorUpdate","defaultAnchor","x","y","_texture","_width","_height","_tint","_tintRGB","tint","blendMode","_cachedTint","uvs","vertexData","Float32Array","vertexTrimmedData","_transformID","_textureID","_transformTrimmedID","_textureTrimmedID","pluginName","isSprite","_roundPixels","__","constructor","prototype","create","__extends","_onTextureUpdate","scale","sign","orig","width","height","calculateVertices","transform","_worldID","_updateID","_uvs","uvsFloat32","wt","worldTransform","a","c","tx","ty","trim","anchor","w0","w1","h0","h1","_x","_y","resolution","i","length","Math","round","calculateTrimmedVertices","_render","renderer","batch","setObjectRenderer","plugins","render","_calculateBounds","_bounds","addQuad","getLocalBounds","rect","children","minX","minY","maxX","maxY","_localBoundsRect","getRectangle","containsPoint","point","applyInverse","x1","y1","destroy","options","off","destroyBaseTexture","baseTexture","from","source","defineProperty","get","set","value","enumerable","configurable","abs","s","copyFrom","valid","once"],"sourceRoot":""}